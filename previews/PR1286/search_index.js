var documenterSearchIndex = {"docs":
[{"location":"conversion/#Conversions","page":"Conversions","title":"Conversions","text":"One of the main ideas of GAP.jl is that automatic conversions of Julia objects to GAP objects and vice versa shall be avoided whenever this is possible. For a few types of objects, such conversions are unavoidable, see Automatic GAP-to-Julia and Julia-to-GAP Conversions.\n\nIn all other situations, the user must explicitly convert between GAP objects and corresponding Julia objects. This is typically done by \"type coercion\", also just called \"coercion\": to convert a Julia object x into a GAP object, you may write GapObj(x), see GapObj. Conversely, if y is a GAP object, then e.g. Vector{Int}(y) will attempt to convert it into a Vector{Int}. This will success if e.g. y is a GAP range or a plain list of integers. See also Constructor Methods for GAP-to-Julia Conversions.\n\nFor interactive use it may also be convenient to use the function gap_to_julia with a single argument, which will attempt to \"guess\" a suitable Julia type for the conversion (e.g. GAP strings will be converted to Julia strings). However, we generally recommend against using it, as usually it is better to coerce to a specific type, as that makes it easier to reason about the code, and helps code to become \"type stable\" (an important concept for writing performant Julia code).","category":"section"},{"location":"conversion/#Automatic-GAP-to-Julia-and-Julia-to-GAP-Conversions","page":"Conversions","title":"Automatic GAP-to-Julia and Julia-to-GAP Conversions","text":"When one calls a GAP function with Julia objects as arguments, or a Julia function with GAP objects as arguments, the arguments are in general not automatically converted to GAP objects or Julia objects, respectively. The exceptions are as follows.\n\nGAP's immediate integers (in the range -2^60 to 2^60-1) are automatically converted to Julia's Int64 objects; Julia's Int64 objects are automatically converted to GAP's immediate integers if they fit, and to GAP's large integers otherwise.\nGAP's immediate finite field elements are automatically converted to Julia's GAP.FFE objects, and vice versa.\nGAP's true and false are automatically converted to Julia's true and false, and vice versa.","category":"section"},{"location":"conversion/#Explicit-GAP-to-Julia-and-Julia-to-GAP-Conversions","page":"Conversions","title":"Explicit GAP-to-Julia and Julia-to-GAP Conversions","text":"The following rules hold for explicit conversions.\n\nJulia types control the conversions.\nFor conversions from Julia to GAP, there is at most one possibility on the GAP side, and the type of the given Julia object determines which code is used.\nFor conversions from GAP to Julia, several Julia types can be possible for the result, for example a GAP integer can be converted to several Julia integer types, or a GAP string can be converted to a Julia String or Tuple. Usually one wants to specify the target type, and then this type determines which code is used for the conversion. If one does not specify the target type, a default type will be chosen.\nCertain Julia types are not supported, for technical reasons. For example, converting a nonempty GAP list to a Julia object of type Set{GapObj} is not possible because no hash method is defined for GapObj.\nSubobjects, recursive conversions\nGAP lists and records can have subobjects, the same holds for various Julia objects such as vectors, matrices, tuples, and dictionaries. One may or may not want to convert the subobjects recursively, this is controlled by the recursive keyword argument of the functions GAP.gap_to_julia and GapObj, which can be set to true or false.\nFor both GAP-to-Julia and Julia-to-GAP conversion, the default is non-recursive conversion.\nFor Julia-to-GAP conversion, recursion stops at subobjects of type GapObj.\nFor GAP-to-Julia conversion, recursion stops at subobjects that do not have the type GAP.Obj.\nFor GAP-to-Julia conversion, the given target type may force a conversion of subobjects up to a certain level also if non-recursive conversion is requested. In this case, recursive conversion means to convert subobjects to Julia also if the result has already the target type.\nFor example, converting a GAP list of lists l to a Julia object of type Vector{Vector{Any}} means to convert the entries of l to Vector{Any} objects, and non-recursive conversion means that the entries of the l[i] will be kept in the result since the type requirement Any is satisfied, whereas these entries will get converted to Julia objects in the case of recursive conversion.\nWhen recursive conversion is requested, identical subobjects in the given object correspond to identical subobjects in the result of the conversion.\nIn order to achieve this, a dictionary gets created in the case of recursive conversion, which stores the subobjects and their conversion results. Some of the implications are as follows.\nRecursive conversion is more expensive than non-recursive conversion.\nIt can happen that the results of recursive and non-recursive conversion are equal, but they differ w.r.t. the identity of subobjects. For example, the two entries of the GAP list GAP.evalstr(\"[ [ 1, 2 ], ~[1] ]\") are identical, the same holds for the two entries of the vector obtained by recursive conversion of this list to an object of type Vector{Vector{Int}}; however, the two entries of the vector obtained by non-recursive conversion of this list to an object of type Vector{Vector{Int}} are equal but not identical.\n(Note that \"identity of objects\" has different meanings in GAP and Julia. For example, converting a GAP list of equal but nonidentical strings to a Julia vector of symbols will yield an object with identical subobjects.)\nMutability of results of conversions\nIn GAP, mutability is defined for individual objects. GAP objects that are newly created by Julia-to-GAP conversions are mutable whenever this is possible.\nIn Julia, mutability is defined for types. (The type GapObj is a mutable type.)\nImplementation of conversion methods\nIn order to install a new GAP-to-Julia conversion for some prescribed target type T, one has to install a GAP.gap_to_julia_internal method where T is specified as the first argument.\nIn order to install a new Julia-to-GAP conversion for objects of type T, one has to install a GAP.GapObj_internal method. If one knows that objects of type T need not support recursive conversion then one can alternatively use the GAP.@install macro for the installation.","category":"section"},{"location":"conversion/#Constructor-Methods-for-GAP-to-Julia-Conversions","page":"Conversions","title":"Constructor Methods for GAP-to-Julia Conversions","text":"(For Julia-to-GAP conversions, one can use GapObj and GAP.Obj as constructors.)","category":"section"},{"location":"conversion/#GAP.gap_to_julia","page":"Conversions","title":"GAP.gap_to_julia","text":"gap_to_julia([type, ]x; recursive::Bool=false)\n\nTry to convert the object x to a Julia object of type type. If x is a GapObj then the conversion rules are defined in the manual of the GAP package JuliaInterface. If x is another GAP.Obj (for example a Int64) then the result is defined in Julia by type.\n\nFor GAP lists and records, it makes sense to either convert also the subobjects recursively, or to keep the subobjects as they are; the behaviour is controlled by recursive, which can be true or false.\n\nExamples\n\njulia> GAP.gap_to_julia(GapObj(1//3))\n1//3\n\njulia> GAP.gap_to_julia(GapObj(\"abc\"))\n\"abc\"\n\njulia> val = GapObj([1 2 ; 3 4])\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\njulia> GAP.gap_to_julia(val, recursive = true)\n2-element Vector{Any}:\n Any[1, 2]\n Any[3, 4]\n\njulia> GAP.gap_to_julia(val)\n2-element Vector{Any}:\n GAP: [ 1, 2 ]\n GAP: [ 3, 4 ]\n\njulia> GAP.gap_to_julia(Vector{GapObj}, val)\n2-element Vector{GapObj}:\n GAP: [ 1, 2 ]\n GAP: [ 3, 4 ]\n\njulia> GAP.gap_to_julia(Matrix{Int}, val)\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\nThe following gap_to_julia conversions are supported by GAP.jl.\n\nGAP filter default Julia type other Julia types\nIsInt BigInt T <: Integer\nIsFFE FFE \nIsBool Bool \nIsRat Rational{BigInt} Rational{T}\nIsFloat Float64 T <: AbstractFloat\nIsChar Cuchar Char\nIsStringRep String Symbol, Vector{T}\nIsRangeRep StepRange{Int64,Int64} Vector{T}\nIsBListRep BitVector Vector{T}\nIsList Vector{Any} Vector{T}\nIsMatrixObj Matrix{Any} Matrix{T}\nIsVectorObj Vector{Any} Vector{T}\nIsRecord Dict{Symbol, Any} Dict{Symbol, T}\n\nOther Julia packages may provide conversions for more GAP types.\n\n\n\n\n\n","category":"function"},{"location":"conversion/#GAP.GapObj-Tuple{Any}","page":"Conversions","title":"GAP.GapObj","text":"GapObj(input, recursive::Bool = false)\n\nOne can use the type GapObj as a constructor, in order to convert the Julia object input to an appropriate GAP object.\n\nIf recursive is set to true, recursive conversion of nested Julia objects (arrays, tuples, and dictionaries) is performed.\n\nExamples\n\njulia> GapObj(1//3)\nGAP: 1/3\n\njulia> GapObj(\"abc\")\nGAP: \"abc\"\n\njulia> GapObj([1 2; 3 4])\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\njulia> GapObj([[1, 2], [3, 4]])\nGAP: [ <Julia: [1, 2]>, <Julia: [3, 4]> ]\n\njulia> GapObj([[1, 2], [3, 4]], true)\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\njulia> GapObj([[1, 2], [3, 4]], recursive = true)\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\nNote that this conversion is not restricted to outputs that actually are of type GapObj, also GAP integers, finite field elements, and booleans can be created by the constructor GapObj.\n\njulia> res = GapObj(42);  res isa GapObj\nfalse\n\njulia> res isa GAP.Obj\ntrue\n\nThe following GapObj conversions are supported by GAP.jl.\n\nJulia type GAP filter\nInt8, Int16, ..., BigInt IsInt\nFFE IsFFE\nBool IsBool\nRational{T} IsRat\nFloat16, Float32, Float64 IsFloat\nAbstractString IsString\nSymbol IsString\nChar IsChar\nVector{T} IsList\nVector{Bool}, BitVector IsBList\nSet{T} IsList\nTuple{T} IsList\nMatrix{T} IsList\nDict{String, T}, Dict{Symbol, T} IsRecord\nUnitRange{T}, StepRange{T, S} IsRange\nFunction IsFunction\n\nOther Julia packages may provide conversions for more Julia types.\n\n\n\n\n\n","category":"method"},{"location":"conversion/#Core.Int128","page":"Conversions","title":"Core.Int128","text":"Int128(obj::GapObj)\n\nReturn the Int128 converted from the GAP integer obj. (Note that small GAP integers are represented by Julia Int64 objects, in particular they are not GapObjs; their conversion is not handled by methods installed in GAP.jl.)\n\nExamples\n\njulia> val = GAP.Globals.Factorial(25)\nGAP: 15511210043330985984000000\n\njulia> Int128(val)\n15511210043330985984000000\n\njulia> Int(val)\nERROR: InexactError: Int64(15511210043330985984000000)\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Base.GMP.BigInt","page":"Conversions","title":"Base.GMP.BigInt","text":"BigInt(obj::GapObj)\n\nReturn the big integer converted from the GAP integer obj. (Note that small GAP integers are not represented by GapObjs, their conversion with BigInt is handled by Julia's methods.)\n\nExamples\n\njulia> val = GAP.Globals.Factorial(25)\nGAP: 15511210043330985984000000\n\njulia> BigInt(val)\n15511210043330985984000000\n\njulia> val = GAP.Globals.Factorial(10)\n3628800\n\njulia> isa(val, GapObj)\nfalse\n\njulia> BigInt(val)\n3628800\n\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Base.Rational","page":"Conversions","title":"Base.Rational","text":"Rational{T}(obj::GapObj) where {T<:Integer}\n\nReturn the rational converted from the GAP integer or the GAP rational obj,\n\nExamples\n\njulia> val = GAP.Globals.Factorial(25)\nGAP: 15511210043330985984000000\n\njulia> Rational{Int128}(val)\n15511210043330985984000000//1\n\njulia> Rational{BigInt}(val)\n15511210043330985984000000//1\n\njulia> val = GAP.Obj(1//3)\nGAP: 1/3\n\njulia> Rational{Int64}(val)\n1//3\n\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Core.Float64","page":"Conversions","title":"Core.Float64","text":"Float64(obj::GapObj)\n\nReturn the float converted from the GAP float obj.\n\nExamples\n\njulia> val = GAP.Obj(2.2)\nGAP: 2.2\n\njulia> Float64(val)\n2.2\n\njulia> Float32(val)\n2.2f0\n\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Core.Char","page":"Conversions","title":"Core.Char","text":"Char(obj::GapObj)\n\nReturn the character converted from the GAP character obj.\n\nExamples\n\njulia> val = GAP.Obj('x')\nGAP: 'x'\n\njulia> Char(val)\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Base.Cuchar","page":"Conversions","title":"Base.Cuchar","text":"Cuchar(obj::GapObj)\n\nReturn the UInt8 that belongs to the GAP character obj.\n\nExamples\n\njulia> val = GAP.Obj('x')\nGAP: 'x'\n\njulia> Cuchar(val)\n0x78\n\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Core.String","page":"Conversions","title":"Core.String","text":"String(obj::GapObj)\n\nReturn the Julia string converted from the GAP string obj. Note that GAP's String function can be applied to arbitrary GAP objects, similar to Julia's string function; this behaviour is not intended for this String constructor.\n\nExamples\n\njulia> val = GAP.Obj(\"abc\")\nGAP: \"abc\"\n\njulia> String(val)\n\"abc\"\n\njulia> val = GAP.Obj([])\nGAP: [  ]\n\njulia> String(val)   # an empty GAP list is a string\n\"\"\n\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Core.Symbol","page":"Conversions","title":"Core.Symbol","text":"Symbol(obj::GapObj)\n\nReturn the symbol converted from the GAP string obj.\n\nExamples\n\njulia> str = GAP.Obj(\"abc\")\nGAP: \"abc\"\n\njulia> Symbol(str)\n:abc\n\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Base.UnitRange","page":"Conversions","title":"Base.UnitRange","text":"UnitRange(obj::GapObj)\n\nReturn the unit range converted from the GAP range obj, which has step width 1.\n\nExamples\n\njulia> val = GAP.Obj(1:10)\nGAP: [ 1 .. 10 ]\n\njulia> UnitRange(val)\n1:10\n\njulia> UnitRange{Int32}(val)\n1:10\n\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Base.StepRange","page":"Conversions","title":"Base.StepRange","text":"StepRange(obj::GapObj)\n\nReturn the step range converted from the GAP range obj, which may have arbitrary step width.\n\nExamples\n\njulia> val = GAP.Obj(1:2:11)\nGAP: [ 1, 3 .. 11 ]\n\njulia> StepRange(val)\n1:2:11\n\njulia> r = StepRange{Int8,Int8}(val)\n1:2:11\n\njulia> typeof(r)\nStepRange{Int8, Int8}\n\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Core.Tuple","page":"Conversions","title":"Core.Tuple","text":"Tuple{Types...}(obj::GapObj; recursive::Bool = false)\n\nReturn the tuple converted from the GAP list obj. The entries of the list are converted to the required types Types.... If recursive is true then the entries of the list are converted recursively, otherwise non-recursively.\n\nExamples\n\njulia> val = GAP.Obj([1, 5])\nGAP: [ 1, 5 ]\n\njulia> Tuple{Int64,Int64}(val)\n(1, 5)\n\njulia> val = GAP.Obj([[1], [2]]; recursive=true)\nGAP: [ [ 1 ], [ 2 ] ]\n\njulia> Tuple{Any,Any}(val; recursive=true)\n(Any[1], Any[2])\n\njulia> Tuple{GapObj,GapObj}(val)\n(GAP: [ 1 ], GAP: [ 2 ])\n\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Base.BitVector","page":"Conversions","title":"Base.BitVector","text":"BitVector(obj::GapObj)\n\nReturn the bit vector converted from the GAP list of booleans obj.\n\nExamples\n\njulia> val = GAP.Obj([true, false, true])\nGAP: [ true, false, true ]\n\njulia> BitVector(val)\n3-element BitVector:\n 1\n 0\n 1\n\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Base.Vector","page":"Conversions","title":"Base.Vector","text":"Vector{T}(obj::GapObj; recursive::Bool = false)\n\nReturn the 1-dimensional array converted from the GAP list obj. The entries of the list are converted to the type T. If recursive is true then the entries of the list are converted recursively, otherwise non-recursively.\n\nIf T is UInt8 then obj may be a GAP string.\n\nExamples\n\njulia> val = GAP.Obj([[1], [2]]; recursive=true)\nGAP: [ [ 1 ], [ 2 ] ]\n\njulia> Vector{Any}(val; recursive=true)\n2-element Vector{Any}:\n Any[1]\n Any[2]\n\njulia> Vector{Any}(val)\n2-element Vector{Any}:\n GAP: [ 1 ]\n GAP: [ 2 ]\n\njulia> Vector{Vector{Int64}}(val)\n2-element Vector{Vector{Int64}}:\n [1]\n [2]\n\njulia> val = GAP.evalstr( \"NewVector( IsPlistVectorRep, Integers, [ 0, 2, 5 ] )\" )\nGAP: <plist vector over Integers of length 3>\n\njulia> Vector{Int64}(val)\n3-element Vector{Int64}:\n 0\n 2\n 5\n\njulia> val = GAP.Obj(\"abc\")\nGAP: \"abc\"\n\njulia> Vector{UInt8}(val)\n3-element Vector{UInt8}:\n 0x61\n 0x62\n 0x63\n\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Base.Matrix","page":"Conversions","title":"Base.Matrix","text":"Matrix{T}(obj::GapObj; recursive::Bool = false)\n\nReturn the 2-dimensional array converted from the GAP matrix obj, which can be a GAP list of lists or a GAP matrix object. The entries of the matrix are converted to the type T. If recursive is true then the entries are converted recursively, otherwise non-recursively.\n\nExamples\n\njulia> val = GAP.Obj([[1, 2], [3, 4]]; recursive=true)\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\njulia> Matrix{Int64}(val)\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> val = GAP.evalstr( \"NewMatrix( IsPlistMatrixRep, Integers, 2, [ 0, 1, 2, 3 ] )\" )\nGAP: <2x2-matrix over Integers>\n\njulia> Matrix{Int64}(val)\n2×2 Matrix{Int64}:\n 0  1\n 2  3\n\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Base.Set","page":"Conversions","title":"Base.Set","text":"Set{T}(obj::GapObj; recursive::Bool = false)\n\nReturn the set converted from the GAP list or GAP collection obj. The elements of obj are converted to the required type T. If recursive is true then the elements are converted recursively, otherwise non-recursively.\n\nThis constructor method is intended for situations where the result involves only native Julia objects such as integers and strings. Dealing with results containing GAP objects will be inefficient.\n\nExamples\n\njulia> Set{Int}(GAP.Obj([1, 2, 1]))\nSet{Int64} with 2 elements:\n  2\n  1\n\njulia> Set{Vector{Int}}(GAP.Obj([[1], [2], [1]]))\nSet{Vector{Int64}} with 2 elements:\n  [1]\n  [2]\n\njulia> Set{String}(GAP.Obj([\"a\", \"b\"]; recursive=true))\nSet{String} with 2 elements:\n  \"b\"\n  \"a\"\n\njulia> Set{Any}(GAP.Obj([[1], [2], [1]]; recursive=true))\nSet{Any} with 2 elements:\n  Any[1]\n  Any[2]\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Base.Dict","page":"Conversions","title":"Base.Dict","text":"Dict{Symbol,T}(obj::GapObj; recursive::Bool = false)\n\nReturn the dictionary converted from the GAP record obj. If recursive is true then the values of the record components are recursively converted to objects of the type T.\n\nExamples\n\njulia> val = GAP.Obj(Dict(:a => 1, :b => 2))\nGAP: rec( a := 1, b := 2 )\n\njulia> Dict{Symbol,Int}(val)\nDict{Symbol, Int64} with 2 entries:\n  :a => 1\n  :b => 2\n\njulia> val = GAP.Obj(Dict(:l => GAP.Obj([1, 2])))\nGAP: rec( l := [ 1, 2 ] )\n\njulia> Dict{Symbol,Any}(val)\nDict{Symbol, Any} with 1 entry:\n  :l => GAP: [ 1, 2 ]\n\njulia> Dict{Symbol,Any}(val; recursive=true)\nDict{Symbol, Any} with 1 entry:\n  :l => Any[1, 2]\n\njulia> Dict{Symbol,Vector{Int}}(val; recursive=true)\nDict{Symbol, Vector{Int64}} with 1 entry:\n  :l => [1, 2]\n\n\n\n\n\n\n","category":"type"},{"location":"manualindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Analyzing-Rubik's-Cube-using-GAP.jl","page":"Examples","title":"Analyzing Rubik's Cube using GAP.jl","text":"The following Julia session shows the GAP computations from the Rubik's Cube example from the GAP webpages.\n\nWe consider the group of transformations of Rubik's magic cube. If we number the faces of this cube as follows\n\n                     +--------------+\n                     |              |\n                     |  1    2    3 |\n                     |              |\n                     |  4  top    5 |\n                     |              |\n                     |  6    7    8 |\n                     |              |\n      +--------------+--------------+--------------+--------------+\n      |              |              |              |              |\n      |  9   10   11 | 17   18   19 | 25   26   27 | 33   34   35 |\n      |              |              |              |              |\n      | 12  left  13 | 20 front  21 | 28 right  29 | 36  rear  37 |\n      |              |              |              |              |\n      | 14   15   16 | 22   23   24 | 30   31   32 | 38   39   40 |\n      |              |              |              |              |\n      +--------------+--------------+--------------+--------------+\n                     |              |\n                     | 41   42   43 |\n                     |              |\n                     | 44 bottom 45 |\n                     |              |\n                     | 46   47   48 |\n                     |              |\n                     +--------------+\n\nthen the group is generated by the following generators, corresponding to the six faces of the cube.\n\njulia> cube = @gap(\"Group(\n        ( 1, 3, 8, 6)( 2, 5, 7, 4)( 9,33,25,17)(10,34,26,18)(11,35,27,19),\n        ( 9,11,16,14)(10,13,15,12)( 1,17,41,40)( 4,20,44,37)( 6,22,46,35),\n        (17,19,24,22)(18,21,23,20)( 6,25,43,16)( 7,28,42,13)( 8,30,41,11),\n        (25,27,32,30)(26,29,31,28)( 3,38,43,19)( 5,36,45,21)( 8,33,48,24),\n        (33,35,40,38)(34,37,39,36)( 3, 9,46,32)( 2,12,47,29)( 1,14,48,27),\n        (41,43,48,46)(42,45,47,44)(14,22,30,38)(15,23,31,39)(16,24,32,40) );\")\nGAP: <permutation group with 6 generators>\n\nFirst we want to know the size of this group.\n\njulia> cube_size = GAP.Globals.Size(cube)\nGAP: 43252003274489856000\n\nSince this is a little bit unhandy, let us factorize this number.\n\njulia> cf = GAP.Globals.Collected(GAP.Globals.Factors(cube_size))\nGAP: [ [ 2, 27 ], [ 3, 14 ], [ 5, 3 ], [ 7, 2 ], [ 11, 1 ] ]\n\n(The result tells us that the size is 2^27 3^14 5^3 7^2 11.)\n\nIn order to convert this GAP list to Julia, we can \"coerce\" it into a Julia Vector, see Conversions:\n\njulia> Vector{Vector{Int}}(cf)\n5-element Vector{Vector{Int64}}:\n [2, 27]\n [3, 14]\n [5, 3]\n [7, 2]\n [11, 1]\n\nNext let us investigate the operation of the group on the 48 points.\n\njulia> orbs = GAP.Globals.Orbits(cube, GapObj(1:48))\nGAP: [ [ 1, 3, 17, 14, 8, 38, 9, 41, 19, 48, 22, 6, 30, 33, 43, 11, 46, 40, 24, 27, 25, 35, 16, 32 ], [ 2, 5, 12, 7, 36, 10, 47, 4, 28, 45, 34, 13, 29, 44, 20, 42, 26, 21, 37, 15, 31, 18, 23, 39 ] ]\n\njulia> length(orbs)\n2\n\nThe first orbit contains the points at the corners, the second those at the edges; clearly the group cannot move a point at a corner onto a point at an edge.\n\nSo to investigate the cube group we first investigate the operation on the corner points. Note that the constructed group that describes this operation will operate on the set [1..24], not on the original set orbs[1].\n\njulia> cube1 = GAP.Globals.Action(cube, orbs[1])\nGAP: <permutation group with 6 generators>\n\njulia> GAP.Globals.NrMovedPoints(cube1)\n24\n\njulia> GAP.Globals.Size(cube1)\n88179840\n\nNow this group obviously operates transitively, but let us test whether it is also primitive.\n\njulia> corners = GAP.Globals.Blocks(cube1, GAP.Globals.MovedPoints(cube1))\nGAP: [ [ 1, 7, 22 ], [ 2, 14, 20 ], [ 3, 12, 16 ], [ 4, 17, 18 ], [ 5, 9, 21 ], [ 6, 10, 24 ], [ 8, 11, 23 ], [ 13, 15, 19 ] ]\n\nThose eight blocks correspond to the eight corners of the cube; on the one hand the group permutes those and on the other hand it permutes the three points at each corner cyclically.\n\njulia> blockhom1 = GAP.Globals.ActionHomomorphism(cube1, corners, GAP.Globals.OnSets)\nGAP: <action homomorphism>\n\njulia> cube1b = GAP.Globals.Image(blockhom1)\nGAP: Group([ (1,2,4,3), (1,3,6,5), (1,5,8,2), (3,4,7,6), (5,6,7,8), (2,8,7,4) ])\n\njulia> GAP.Globals.Size(cube1b)\n40320\n\nNow a permutation group of degree 8 that has order 40320 must be the full symmetric group Sym(8) on eight points.\n\nThe next thing then is to investigate the kernel of this operation on blocks, i.e., the subgroup of cube1 of those elements that fix the blocks setwise.\n\njulia> ker1 = GAP.Globals.Kernel(blockhom1)\nGAP: <permutation group with 7 generators>\n\njulia> println(Vector{Int}(GAP.Globals.Factors(GAP.Globals.Size(ker1))))\n[3, 3, 3, 3, 3, 3, 3]\n\njulia> GAP.Globals.IsElementaryAbelian(ker1)\ntrue\n\nWe can show that the product of this elementary abelian group 3^7 with the Sym(8) is semidirect by finding a complement, i.e., a subgroup that has trivial intersection with the kernel and that generates cube1 together with the kernel.\n\njulia> cmpl1 = GAP.Globals.ComplementClassesRepresentatives(cube1, ker1)\nGAP: [ <permutation group of size 40320 with 7 generators> ]\n\njulia> cmpl1 = cmpl1[1]; GAP.Globals.Size(cmpl1)\n40320\n\nWe verify the complement properties:\n\njulia> GAP.Globals.Size(GAP.Globals.Intersection(cmpl1, ker1))\n1\n\njulia> GAP.Globals.ClosureGroup(cmpl1, ker1) == cube1\ntrue\n\nThere is even a more elegant way to show that cmpl1 is a complement.\n\njulia> GAP.Globals.IsBijective(GAP.Globals.RestrictedMapping(blockhom1, cmpl1))\ntrue\n\nOf course, theoretically it is clear that cmpl1 must indeed be a complement.\n\nIn fact we know that cube1 is a subgroup of index 3 in the wreath product of a cyclic 3 with Sym(8). This missing index 3 tells us that we do not have total freedom in turning the corners. The following tests show that whenever we turn one corner clockwise we must turn another corner counterclockwise.\n\njulia> @gap(\"(1, 7, 22)\") in cube1\nfalse\n\njulia> @gap(\"(1, 7, 22)(2, 20, 14)\") in cube1\ntrue\n\nMore or less the same things happen when we consider the operation of the cube group on the edges.\n\njulia> cube2 = GAP.Globals.Action(cube, orbs[2]); GAP.Globals.Size(cube2)\n980995276800\n\njulia> edges = GAP.Globals.Blocks(cube2, GAP.Globals.MovedPoints(cube2))\nGAP: [ [ 1, 11 ], [ 2, 17 ], [ 3, 19 ], [ 4, 22 ], [ 5, 13 ], [ 6, 8 ], [ 7, 24 ], [ 9, 18 ], [ 10, 21 ], [ 12, 15 ], [ 14, 20 ], [ 16, 23 ] ]\n\njulia> blockhom2 = GAP.Globals.ActionHomomorphism(cube2, edges, GAP.Globals.OnSets);\n\njulia> cube2b = GAP.Globals.Image(blockhom2); GAP.Globals.Size(cube2b)\n479001600\n\njulia> ker2 = GAP.Globals.Kernel(blockhom2)\nGAP: <permutation group with 11 generators>\n\njulia> GAP.Globals.Factors(GAP.Globals.Size(ker2))\nGAP: [ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 ]\n\njulia> GAP.Globals.IsElementaryAbelian(ker2)\ntrue\n\njulia> cmpl2 = GAP.Globals.ComplementClassesRepresentatives(cube2, ker2); length(cmpl2)\n4\n\nSo there are even 4 classes of complements here. This time we get a semidirect product of a 2^11 with an Sym(12), namely a subgroup of index 2 of the wreath product of a cyclic 2 with Sym(12). Here the missing index 2 tells us again that we do not have total freedom in turning the edges. The following tests show that whenever we flip one edge we must also flip another edge.\n\njulia> @gap(\"(1, 11)\") in cube2\nfalse\n\njulia> @gap(\"(1, 11)(2, 17)\") in cube2\ntrue\n\nSince cube1 and cube2 are the groups describing the actions on the two orbits of cube, it is clear that cube is a subdirect product of those groups, i.e., a subgroup of the direct product. Comparing the sizes of cube1, cube2, and cube we see that cube must be a subgroup of index 2 in the direct product of those two groups.\n\njulia> BigInt(GAP.Globals.Size(cube1)) * BigInt(GAP.Globals.Size(cube2))\n86504006548979712000\n\njulia> GAP.Globals.Size(cube)\nGAP: 43252003274489856000\n\n(Note that both GAP.Globals.Size(cube1) and GAP.Globals.Size(cube2) have the Julia type Int64, and forming their product yields an overflow. In order to obtain the correct value we have created arbitrary precision integers for the two values before multiplying them.)\n\nThis final missing index 2 tells us that we cannot operate on corners and edges totally independently. The following tests show that whenever we exchange a pair of corners we must also exchange a pair of edges (and vice versa).\n\njulia> @gap(\"(17, 19)(11, 8)(6, 25)\") in cube\nfalse\n\njulia> @gap(\"(7, 28)(18, 21)\") in cube\nfalse\n\njulia> @gap(\"(17, 19)(11, 8)(6, 25)(7, 28)(18, 21)\") in cube\ntrue\n\nAs a last part of the structure analysis of the cube group let us compute the centre of the cube group, i.e., the subgroup of those operations that can be performed either before or after any other operation with the same result.\n\njulia> z = GAP.Globals.Centre(cube)\nGAP: Group([ (2,34)(4,10)(5,26)(7,18)(12,37)(13,20)(15,44)(21,28)(23,42)(29,36)(31,45)(39,47) ])\n\nWe see that the centre contains one nontrivial element, namely the operation that flips all 12 edges simultaneously.\n\nFinally we turn to the original idea connected with the cube, namely to find a sequence of turns of the faces that will transform the cube back into its original state. This amounts to a decomposition of a given element of the cube group into a product of the generators. For this purpose we introduce a free group and a homomorphism of it onto the cube group.\n\njulia> f = GAP.Globals.FreeGroup(GapObj([\"t\", \"l\", \"f\", \"r\", \"e\", \"b\"], recursive =  true))\nGAP: <free group on the generators [ t, l, f, r, e, b ]>\n\njulia> fhom = GAP.Globals.GroupHomomorphismByImages(f, cube)\nGAP: [ t, l, f, r, e, b ] -> [ (1,3,8,6)(2,5,7,4)(9,33,25,17)(10,34,26,18)(11,35,27,19), (1,17,41,40)(4,20,44,37)(6,22,46,35)(9,11,16,14)(10,13,15,12), (6,25,43,16)(7,28,42,13)(8,30,41,11)(17,19,24,22)(18,21,23,20), (3,38,43,19)(5,36,45,21)(8,33,48,24)(25,27,32,30)(26,29,31,28), (1,14,48,27)(2,12,47,29)(3,9,46,32)(33,35,40,38)(34,37,39,36), (14,22,30,38)(15,23,31,39)(16,24,32,40)(41,43,48,46)(42,45,47,44) ]\n\nUsing this homomorphism, we can now decompose elements into generators. The method used utilizes a stabilizer chain and does not enumerate all group elements, therefore the words obtained are not the shortest possible, though they are short enough for hand solutions.\n\nThe computed decompositions may be different in different sessions, because they involve the computation of pseudo random elements. Therefore the results shown in the following may look different in actual Julia sessions.\n\nFirst we decompose the nonidentity centre element:\n\njulia> zgen = GAP.Globals.GeneratorsOfGroup(z)[1]\nGAP: (2,34)(4,10)(5,26)(7,18)(12,37)(13,20)(15,44)(21,28)(23,42)(29,36)(31,45)(39,47)\n\njulia> pre1 = GAP.Globals.PreImagesRepresentative(fhom, zgen)\nGAP: t^-1*l*t*l^-1*e^-1*t*f^-1*e*l*f*(t^-1*l^-1)^2*t*l*f*t*r*t^-1*r^-1*f^-1*l^-1*e^-1*t^-1*e*t*l*t*f*t*r*t^-1*r^-1*f^-1*t^-2*f*t^-1*f^-1*t^2*e*l^-1*e^-1*t^-1*l*t*l*f*t^-1*f^-1*l^-1*t*l*t^2*l^-1*t^-1*l*t^-1*l^-1*t^2*f^-1*l^-1*t^-1*l*t*f*t*l^-1*t*l*f^-1*l*f*l^-1*t^-2*l^-1*f^-1*l*f*l*t*e^-1*t*e*l*t*l^-1*e*l*e^-1*t^-1*f*l*f*l^-1*f^-1*t^-2*f^-1*t*l^-1*f*t^-2*f^-2*b*r^-1*b^-1*t^-2*e^-1*r^-2*e*t^-1*r*b*e^-1*b^-1*l^-1*r^-2*t^-2*l^-1*b^-1*r^-1*e^-1\n\njulia> length(pre1)\n134\n\nNext we decompose some element arbitrarily chosen by us:\n\njulia> pre2 = GAP.Globals.PreImagesRepresentative(fhom, @gap(\"(17, 19)(11, 8)(6, 25)(7, 28)(18, 21)\"))\nGAP: l^-1*t^-1*l*f*r*t*r^-1*f^-1*l*t*f*t^-1*f^-1*l^-1*t^2*f*t*l*t*l^-1*f^-1*l*t^-1*l^-1*f*t^-1*f^-1*l*t*l^-1*t*l*t^-2*l^-1*f*(t*r*t^-1*r^-1)^2*f^-1*t*l*f^-1*l^-1*f*l^-1*t^-1*l*t^-2*f*t*(f^-1*l^-1)^2*l^-1*f*l*e^-1*t*e*l*t^-1*e^-1*t^-1*e*l*b*f^-1*b^-1\n\njulia> length(pre2)\n77\n\nLast we let GAP choose a random element ...\n\njulia> r = GAP.Globals.Random(cube)\nGAP: (1,6,9,17,35,11)(2,13,29,42,4,34,20,36,23,10)(3,22,14,8,38,24,27,16,40,19,32,43,33,41,46,25,48,30)(5,39,28,37,18,31,44,26,47,21,12,7,45,15)\n\njulia> pre3 = GAP.Globals.PreImagesRepresentative(fhom, r)\nGAP: r*e^-1*t^-1*e^-1*r^-2*e*f*t^2*b^-1*e^-1*b*l*f^-1*r*t^-1*r^-1*l*b*f^-2*b^-1*f^-1*l*f*t^-1*l^-1*f^-1*l^-1*f*e*l^-1*e^-1*l^-2*t^-1*l*f^-1*l^-1*f*l^-1*t^-1*l^2*f*t*f^-1*(t^-1*l^-1)^3*e*l*e^-1*t*l*t^-1*l*t^2*l^-1*t^-1*l*t^-1*l^-1*f*t*f^-1*l*t*l^-1*f*l*t^-1*l^-1*t^-1*f^-1*t^-1*f*r*t*r^-1*t^-1*f^-1*t^-1*l^-1*t^-1*e^-1*t*e*l*f*r*t*r^-1*t^-1*f^-1*l^-1*t^-1*(l*t)^2*f^-1*l^-1*e^-1*f*t^-1*e*l*t^-1*l^-1*t\n\njulia> length(pre3)\n116\n\n... and we verify that the decomposition is correct:\n\njulia> GAP.Globals.Image(fhom, pre3) == r\ntrue\n\nThis concludes our example.","category":"section"},{"location":"basics/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"basics/#Accessing-GAP-from-Julia","page":"Basics","title":"Accessing GAP from Julia","text":"Any global GAP variable and function can be accessed from Julia via the GAP.Globals object; for example GAP.Globals.Binomial(5,3). See Convenience adapters for dealing with GAP syntax beyond simple function calls.\nThe GAP.prompt command can be used to switch to a GAP session that works like a regular GAP, except that leaving it (via quit; or by pressing Ctrl-D) returns one to a Julia prompt. From the GAP prompt, one can access Julia variables via the Julia object, for example Julia.binomial(5,3). For more details on how to access Julia from GAP, please consult the manual of the GAP package JuliaInterface.\nAlternatively, one can start GAP in the traditional way, by executing a shell script. Such a script can be created in a location of your choice via GAP.create_gap_sh. Note that one cannot switch from such a GAP session to the underlying Julia session and back.","category":"section"},{"location":"basics/#Accessing-Julia-from-GAP","page":"Basics","title":"Accessing Julia from GAP","text":"The GAP-Julia interface is fully bidirectional, so it is also possible to access all Julia functionality from GAP. To learn more about this, please consult the manual of the GAP package JuliaInterface.","category":"section"},{"location":"basics/#Types","page":"Basics","title":"Types","text":"","category":"section"},{"location":"basics/#GAP.Globals","page":"Basics","title":"GAP.Globals","text":"Globals\n\nThis is a global object that gives access to all global variables of the current GAP session via getproperty and setproperty!.\n\nExamples\n\njulia> GAP.Globals.Size    # a global GAP function\nGAP: <Attribute \"Size\">\n\njulia> GAP.Globals.size    # there is no GAP variable with this name\nERROR: GAP variable size not bound\n[...]\n\njulia> hasproperty( GAP.Globals, :size )\nfalse\n\njulia> GAP.Globals.size = 17;\n\njulia> hasproperty( GAP.Globals, :size )\ntrue\n\njulia> GAP.Globals.size\n17\n\njulia> GAP.Globals.UnbindGlobal(g\"size\")\n\njulia> GAP.Globals.Julia   # Julia objects can be values of GAP variables\nMain\n\n\n\n\n\n\n","category":"constant"},{"location":"basics/#GAP.evalstr","page":"Basics","title":"GAP.evalstr","text":"evalstr(cmd::String)\n\nLet GAP execute the command(s) given by cmd; if an error occurs then report this error, otherwise if the last command has a result then return it, otherwise return nothing.\n\nExamples\n\njulia> GAP.evalstr( \"1+2\" )\n3\n\njulia> GAP.evalstr( \"x:= []\" )\nGAP: [  ]\n\njulia> GAP.evalstr( \"y:= 2; Add( x, y )\" )\n\njulia> GAP.evalstr( \"x\" )\nGAP: [ 2 ]\n\njulia> GAP.evalstr( \"Print( x )\" )\n\nNote that screen outputs caused by evaluating cmd are not shown by evalstr; use evalstr_ex for accessing both the outputs and the return values of the command(s).\n\nIn general we recommend to avoid using evalstr, but it sometimes can be a useful escape hatch to access GAP functionality that is otherwise impossible to difficult to reach. But in most typical scenarios it should not be necessary to use it at all.\n\nInstead, use GapObj or GAP.Obj for constructing GAP objects that correspond to given Julia objects, and call GAP functions directly in the Julia session. For example, executing GAP.evalstr( \"x:= []; Add( x, 2 )\" ) can be replaced by the Julia code x = GapObj([]); GAP.Globals.Add(x, 2). Note that the variable x in the former example lives in the GAP session, i.e., it can be accessed as GAP.Globals.x after the call of GAP.evalstr, whereas x in the latter example lives in the Julia session.\n\n\n\n\n\n","category":"function"},{"location":"basics/#GAP.evalstr_ex","page":"Basics","title":"GAP.evalstr_ex","text":"evalstr_ex(cmd::String)\n\nAssume that cmd consists of n GAP statements, each terminated by ; or ;;. Let GAP execute these statements and return a GAP list of length n that describes their results. Each entry of the return value is a GAP list of length 5, with the following meaning.\n\nThe first entry is true if the statement was executed successfully, and false otherwise.\nIf the first entry is true, then the second entry is bound to the result of the statement if there was one, and unbound otherwise.\nThe third entry is unbound if an error occured, true if the statement ends in a double semicolon, and false otherwise.\nThe fourth entry currently is always unbound.\nThe fifth entry contains the captured output of the statement as a string. If there was no double semicolon then also the output of GAP.Globals.ViewObj applied to the result value in the second entry, if any, is part of that string.\n\nExamples\n\njulia> GAP.evalstr_ex( \"1+2\" )        # error due to missing semicolon\nGAP: [ [ false,,,, \"\" ] ]\n\njulia> GAP.evalstr_ex( \"1+2;\" )       # one statement with return value\nGAP: [ [ true, 3, false,, \"3\" ] ]\n\njulia> GAP.evalstr_ex( \"1+2;;\" )      # the same with suppressed output\nGAP: [ [ true, 3, true,, \"\" ] ]\n\njulia> GAP.evalstr_ex( \"x:= []; Add(x, 1);\" )  # two valid commands\nGAP: [ [ true, [ 1 ], false,, \"[  ]\" ], [ true,, false,, \"\" ] ]\n\njulia> GAP.evalstr_ex( \"1/0; 1+1;\" )  # one error, one valid command\nGAP: [ [ false,,,, \"\" ], [ true, 2, false,, \"2\" ] ]\n\njulia> GAP.evalstr_ex( \"Print(1);\" )  # no return value but output\nGAP: [ [ true,, false,, \"1\" ] ]\n\njulia> GAP.evalstr_ex( \"\" )           # empty input\nGAP: [  ]\n\n\n\n\n\n","category":"function"},{"location":"basics/#GAP.prompt","page":"Basics","title":"GAP.prompt","text":"prompt()\n\nStart a GAP prompt where you can enter GAP commands as in a regular GAP session. This prompt can be left as any GAP prompt by either entering quit; or pressing ctrl-D, which returns to the Julia prompt.\n\nThis GAP prompt allows to quickly switch between writing Julia and GAP code in a session where all data is shared.\n\n\n\n\n\n","category":"function"},{"location":"basics/#GAP.Setup.create_gap_sh","page":"Basics","title":"GAP.Setup.create_gap_sh","text":"create_gap_sh(dstdir::String; use_active_project::Bool=false)\n\nCreate a shell script gap.sh file in the directory at path dstdir which launches GAP via Julia.\n\nThis script behaves from the outside like a regular GAP executable. You can verify that it really loads GAP via Julia by looking at the Configuration line in the GAP banner.\n\nIf use_active_project is false, then it also creates two TOML files, Manifest.toml and Project.toml, in dstdir, which are used by gap.sh to fix the precise versions of GAP.jl and other Julia packages involved.\n\nIf use_active_project is true, then it instead uses whatever is the active project when create_gap_sh is run.\n\n\n\n\n\n","category":"function"},{"location":"basics/#GAP.FFE","page":"Basics","title":"GAP.FFE","text":"FFE\n\nWrap a pointer to a GAP FFE (\"finite field element\") immediate object. This type is defined in the JuliaInterface C code.\n\nExamples\n\njulia> x = GAP.Globals.Z(3)\nGAP: Z(3)\n\njulia> typeof(x)\nFFE\n\n\n\n\n\n","category":"type"},{"location":"basics/#GAP.GapObj","page":"Basics","title":"GAP.GapObj","text":"GapObj\n\nThis is the Julia type of all those GAP objects that are not \"immediate\" (booleans, small integers, FFEs).\n\nExamples\n\njulia> typeof(GapObj([1, 2]))          # a GAP list\nGapObj\n\njulia> typeof(GapObj(Dict(:a => 1)))   # a GAP record\nGapObj\n\njulia> typeof( GAP.evalstr( \"(1,2,3)\" ) )  # a GAP permutation\nGapObj\n\njulia> typeof( GAP.evalstr( \"2^64\" ) )     # a large GAP integer\nGapObj\n\njulia> typeof( GAP.evalstr( \"2^59\" ) )     # a small GAP integer\nInt64\n\njulia> typeof( GAP.evalstr( \"Z(2)\" ) )     # a GAP FFE\nFFE\n\njulia> typeof( GAP.evalstr( \"true\" ) )     # a boolean\nBool\n\nNote that this is Julia's viewpoint on GAP objects. From the viewpoint of GAP, also the pointers to Julia objects are implemented as \"non-immediate GAP objects\", but they appear as Julia objects to Julia, not \"doubly wrapped\".\n\nExamples\n\njulia> GAP.evalstr( \"Julia.Base\" )\nBase\n\njulia> typeof( GAP.evalstr( \"Julia.Base\" ) )        # native Julia object\nModule\n\nEquality of two GapObjs is defined by delegating to GAP's equality test. Since GAP does not define hash values for its objects, it cannot provide data for a nontrivial hash method for the type GapObj. This is because a hash method must satisfy the condition that a == b implies hash(a) == hash(b). The only universal way to guarantee that would be to define hash to be constant on objects of type GapObj, but this would lead to inefficient code. Therefore we decided to throw an error exception whenever hash is called with a GapObj. This implies that for example no nonempty object of the Julia type Set{GapObj} can be created.\n\nOne can use GapObj as a constructor, in order to convert Julia objects to GAP objects, see GapObj(x; recursive::Bool = false) for that.\n\n\n\n\n\n","category":"type"},{"location":"basics/#GAP.Obj","page":"Basics","title":"GAP.Obj","text":"GAP.Obj\n\nThis is an alias for Union{GapObj,FFE,Int64,Bool}. This type union covers all types a \"native\" GAP object may have from Julia's viewpoint.\n\nMoreover, it can be used as a constructor, in order to convert Julia objects to GAP objects, whenever a suitable conversion has been defined.\n\nRecursive conversion of nested Julia objects (arrays, tuples, dictionaries) can be forced either by a second argument true or by the keyword argument recursive with value true.\n\nExamples\n\njulia> GAP.Obj(1//3)\nGAP: 1/3\n\njulia> GAP.Obj([1 2; 3 4])\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\njulia> GAP.Obj([[1, 2], [3, 4]])\nGAP: [ <Julia: [1, 2]>, <Julia: [3, 4]> ]\n\njulia> GAP.Obj([[1, 2], [3, 4]], true)\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\njulia> GAP.Obj([[1, 2], [3, 4]], recursive=true)\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\njulia> GAP.Obj(42)\n42\n\n\n\n\n\n","category":"type"},{"location":"basics/#GAP.GapInt","page":"Basics","title":"GAP.GapInt","text":"GapInt\n\nAny GAP integer object is represented in Julia as either a GapObj (if it is a \"large\" integer) or as an Int (if it is a \"small\" integer). This type union can be used to express this conveniently, e.g. when one wants to help type stability.\n\nNote that also GAP's infinity and -infinity fit under this type (as do many other objects which are not numbers).\n\n\n\n\n\n","category":"type"},{"location":"internal/#Internal","page":"Internal","title":"Internal","text":"","category":"section"},{"location":"internal/#GAP.versioninfo","page":"Internal","title":"GAP.versioninfo","text":"versioninfo(io::IO = stdout; jll::Bool = false, full::Bool = false)\n\nPrint to io the versions of GAP.jl and GAP, and version and installation paths of all loaded GAP packages.\n\nNote that these paths can be nonstandard because Julia's package manager does not control which available version of a GAP package gets loaded.\n\nIf jll or full is true then also the underlying binary packages (jll), if available, of all installed (not necessarily loaded) packages are included in the output.\n\n\n\n\n\n","category":"function"},{"location":"internal/#GAP.get_symbols_in_module","page":"Internal","title":"GAP.get_symbols_in_module","text":"get_symbols_in_module(m::Module) :: Vector{Symbol}\n\nReturn all symbols in the module m. This is used in a GAP method for RecNames.\n\n\n\n\n\n","category":"function"},{"location":"internal/#GAP.GAP","page":"Internal","title":"GAP.GAP","text":"GAP.jl is the Julia interface to the GAP-System.\n\nFor the package manual see   https://oscar-system.github.io/GAP.jl/.\n\nFor more information about GAP see   https://www.gap-system.org/.\n\n\n\n\n\n","category":"module"},{"location":"internal/#GAP.RecDict_g","page":"Internal","title":"GAP.RecDict_g","text":"RecDict_g = IdDict{Any,Any}\n\nAn internal type of GAP.jl used for tracking conversion results in julia_to_gap. The value stored at the key obj is the result of the Julia to GAP conversion of obj.\n\n\n\n\n\n","category":"type"},{"location":"internal/#GAP.RecDict_j","page":"Internal","title":"GAP.RecDict_j","text":"RecDict_j = IdDict{Tuple{Any, Type}, Any}\n\nAn internal type of GAP.jl used for tracking conversion results in gap_to_julia. The value stored at the key (obj, T) is the result of the GAP to Julia conversion of obj that has type T. Note that several Julia types can occur for the same GAP object.\n\nLookups for the key (obj, T) in an IdDict are successful if the conversion result of an object identical to obj with target type T has been stored in the dictionary.\n\nNote that comparing two GapObjs with === yields the same result as comparing them with GAP.Globals.IsIdenticalObj because GapObj is a mutable type.\n\n\n\n\n\n","category":"type"},{"location":"internal/#GAP.GapObj_internal","page":"Internal","title":"GAP.GapObj_internal","text":"GapObj_internal(x::Any, rec_dict::GapCacheDict, ::Val{recursive}) where recursive\n\nReturn a GapObj that corresponds to the Julia object x.\n\nThe value of recursive can be GAP.BoolVal(true) or GAP.BoolVal(false), the former meaning that subobjects of x shall get converted recursively, the latter meaning that no recursion is requested. In the case of recursive conversion, a dictionary is used as the value of rec_dict in order to make sure that identical subobjects of x correspond to identical subobjects in the result of the conversion. This dictionary is created automatically on demand, it should never be supplied by the user.\n\nThe function GapObj_internal may call GapObj, but the other direction is not allowed.\n\nNew methods for Julia-to-GAP conversions must be implemented via methods for GapObj_internal not for GapObj.\n\n\n\n\n\n","category":"function"},{"location":"internal/#GAP.gap_to_julia_internal","page":"Internal","title":"GAP.gap_to_julia_internal","text":"gap_to_julia_internal(::Type{T}, x::Any, rec_dict::JuliaCacheDict,\n                      ::Val{recursive}) where {T, recursive}\n\nReturn an object of type T that corresponds to the GAP object x.\n\nThe value of recursive can be Val(true) or Val(false), the former meaning that subobjects of x shall get converted recursively, the latter meaning that no recursion is requested. In the case of recursive conversion, a dictionary is used as the value of rec_dict in order to make sure that identical subobjects of x correspond to identical subobjects in the result of the conversion. This dictionary is created automatically on demand, it should never be supplied by the user.\n\nThe function gap_to_julia may call gap_to_julia_internal, but the other direction is not allowed.\n\nNew methods for GAP-to-Julia conversions must be implemented via methods for gap_to_julia_internal not for gap_to_julia.\n\n\n\n\n\n","category":"function"},{"location":"internal/#GAP._gap_to_julia","page":"Internal","title":"GAP._gap_to_julia","text":"_gap_to_julia([::Type{T}, ]x::Obj[, recursive::Bool])\n\nThis function implements the GAP function GAPToJulia. It just delegates to gap_to_julia. Its purpose is to turn the recursive argument into a keyword argument, which is easier in Julia than in GAP.\n\n\n\n\n\n","category":"function"},{"location":"internal/#GAP._default_type","page":"Internal","title":"GAP._default_type","text":"_default_type(x::GapObj, recursive::Bool)\n\nReturn T, rec where T is a Julia type to which x will be converted by gap_to_julia if no type is prescribed, and rec is a Boolean indicating whether recursive conversion of x makes sense.\n\nT depends on the GAP filters of x. If recursive is false then rec is also false.\n\nThe return value Any, false means that no default is provided, that is, converting x to Julia with gap_to_julia requires a type as the first argument.\n\n\n\n\n\n","category":"function"},{"location":"internal/#GAP.kwarg_wrapper","page":"Internal","title":"GAP.kwarg_wrapper","text":"kwarg_wrapper(func, args::Vector{T1}, kwargs::Dict{Symbol,T2}) where {T1, T2}\n\nCall the function func with arguments args and keyword arguments given by the keys and values of kwargs.\n\nThis function is used on the GAP side, in calls of Julia functions that require keyword arguments.\n\nExamples\n\njulia> range(2, length = 5, step = 2)\n2:2:10\n\njulia> GAP.kwarg_wrapper(range, [2], Dict(:length => 5, :step => 2))\n2:2:10\n\n\n\n\n\n","category":"function"},{"location":"other/#Other-stuff","page":"Other stuff","title":"Other stuff","text":"","category":"section"},{"location":"other/#Macros","page":"Other stuff","title":"Macros","text":"","category":"section"},{"location":"other/#Convenience-adapters","page":"Other stuff","title":"Convenience adapters","text":"This section describes how one can manipulate GAP objects from the Julia side, using Julia syntax features.\n\nIn particular, the following is available on the Julia side in order to support special GAP syntax beyond function calls with arguments.\n\nCall functions with global options via call_gap_func or using Julia's keyword argument syntax. For example, Cyc(1.41421356 : bits:=20) in GAP translates to GAP.Globals.Cyc(GAP.Obj(1.41421356); bits=20) in Julia.\nAccess list/matrix entries via getindex and setindex! respectively the corresponding Julia syntax (described there).\nAccess record components via getproperty and setproperty! respectively the corresponding Julia syntax (described there).\nCheck for bound record components via hasproperty.\nAccess entries of a positional object via getbangindex, equivalent to GAP's ![] operator.\nAccess components of a component object via getbangproperty, equivalent to GAP's !. operator.\nIterate over a GAP list or collection (such as a GAP domain) obj via for x in obj, or map(f, obj) for a unary function f, or [f(x) for x in obj]. If obj is not a list then a GAP iterator for obj gets constructed.\n\njulia> l = [1, 2, 3];  gl = GapObj(l)\nGAP: [ 1, 2, 3 ]\n\njulia> ll = [];  for x in gl push!(ll, x); end;  ll == l\ntrue\n\njulia> map(x -> x, gl) == l\ntrue\n\njulia> [x for x in gl] == l\ntrue\n\nIterating in Julia over a GAP list obj skips the unbound entries in obj, like iterating in GAP does.\n\njulia> gl = GAP.evalstr(\"[1,, 3]\")\nGAP: [ 1,, 3 ]\n\njulia> ll = [];  for x in gl push!(ll, x); end;  ll\n2-element Vector{Any}:\n 1\n 3\n\nNote that iterating in Julia over a GAP iterator object obj does not change obj, whereas iterating in GAP over obj changes obj.\n\njulia> g = GAP.Globals.SymmetricGroup(3)\nGAP: Sym( [ 1 .. 3 ] )\n\njulia> iter = GAP.Globals.Iterator(g)\nGAP: <iterator>\n\njulia> [x for x in iter] == collect(g)\ntrue\n\njulia> [x for x in iter] == collect(g)\ntrue\n\njulia> f = GAP.evalstr(\"function(itr) local res, i; res:= [];\" *\n             \"for i in itr do Add( res, i ); od; return res; end\")\nGAP: function( itr ) ... end\n\njulia> f( iter )\nGAP: [ (), (2,3), (1,3), (1,3,2), (1,2,3), (1,2) ]\n\njulia> f( iter )\nGAP: [  ]\n\nFor the following Julia functions, methods are provided that deal with the case that the arguments are GAP objects; they delegate to the corresponding GAP operations.\n\nJulia GAP\nlength Length\nin \\in\nzero ZeroSameMutability\none OneSameMutability\n- (unary) AdditiveInverseSameMutability\ninv InverseSameMutability\n+ SUM\n- (binary) DIFF\n* PROD\n/ QUO\n\\ LQUO\n^ POW\nmod MOD\n< LT\n== EQ\n\nThe reason why four SameMutability operations are chosen in this list is as follows. In GAP, binary arithmetic operations return immutable results if and only if the two arguments are immutable. Thus it is consistent if unary arithmetic operations return a result with the same mutability as the argument. Note that GAP provides several variants of these unary operations, regarding the mutability of the result (ZeroMutable, ZeroImmutable, ZeroSameMutability, etc.), but here we have to choose one behaviour for the Julia function.\n\njulia> l = GapObj( [ 1, 3, 7, 15 ] )\nGAP: [ 1, 3, 7, 15 ]\n\njulia> m = GapObj( [ 1 2; 3 4 ] )\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\njulia> length( l )\n4\n\njulia> length( m )  # different from Julia's behaviour\n2\n\njulia> 1 in l\ntrue\n\njulia> 2 in l\nfalse\n\njulia> zero( l )\nGAP: [ 0, 0, 0, 0 ]\n\njulia> one( m )\nGAP: [ [ 1, 0 ], [ 0, 1 ] ]\n\njulia> - l\nGAP: [ -1, -3, -7, -15 ]\n\njulia> l + 1\nGAP: [ 2, 4, 8, 16 ]\n\njulia> l + l\nGAP: [ 2, 6, 14, 30 ]\n\njulia> m + m\nGAP: [ [ 2, 4 ], [ 6, 8 ] ]\n\njulia> 1 - m\nGAP: [ [ 0, -1 ], [ -2, -3 ] ]\n\njulia> l * l\n284\n\njulia> l * m\nGAP: [ 10, 14 ]\n\njulia> m * m\nGAP: [ [ 7, 10 ], [ 15, 22 ] ]\n\njulia> 1 / m\nGAP: [ [ -2, 1 ], [ 3/2, -1/2 ] ]\n\njulia> m / 2\nGAP: [ [ 1/2, 1 ], [ 3/2, 2 ] ]\n\njulia> 2 \\ m\nGAP: [ [ 1/2, 1 ], [ 3/2, 2 ] ]\n\njulia> m ^ 2\nGAP: [ [ 7, 10 ], [ 15, 22 ] ]\n\njulia> m ^ -1\nGAP: [ [ -2, 1 ], [ 3/2, -1/2 ] ]\n\njulia> mod( l, 3 )\nGAP: [ 1, 0, 1, 0 ]\n\njulia> m < 2 * m\ntrue\n\njulia> m^2 - 5 * m == 2 * one( m )\ntrue\n","category":"section"},{"location":"other/#Access-to-the-GAP-help-system","page":"Other stuff","title":"Access to the GAP help system","text":"","category":"section"},{"location":"other/#GAP.@gap","page":"Other stuff","title":"GAP.@gap","text":"@gap <expr>\n@gap(<expr>)\n\nExecute <expr> directly in GAP, as if GAP.evalstr(\"<expr>\") was called. This can be used for creating GAP literals directly from Julia.\n\nExamples\n\njulia> @gap [1,2,3]\nGAP: [ 1, 2, 3 ]\n\njulia> @gap SymmetricGroup(3)\nGAP: Sym( [ 1 .. 3 ] )\n\njulia> @gap(SymmetricGroup)(3)\nGAP: Sym( [ 1 .. 3 ] )\n\n\nNote that the last two examples have a slight syntactical, and therefore also a semantical difference. The first one executes the string SymmetricGroup(3) directly inside GAP. The second example returns the function SymmetricGroup via @gap(SymmetricGroup), then calls that function with the argument 3.\n\nDue to Julia's way of handing over arguments into the code of macros, not all expressions representing valid GAP code can be processed. For example, the GAP syntax of permutations consisting of more than one cycle cause problems, as well as the GAP syntax of non-dense lists.\n\njulia> @gap (1,2,3)\nGAP: (1,2,3)\n\njulia> @gap (1,2)(3,4)\nERROR: LoadError: Error thrown by GAP: Error, no method found! For debugging hints type ?Recovery from NoMethodFound\n[...]\n\njulia> @gap [ 1,, 2 ]\nERROR: syntax: unexpected \",\"\n[...]\n\n\nNote also that a string argument gets evaluated with GAP.evalstr.\n\njulia> @gap \"\\\"abc\\\"\"\nGAP: \"abc\"\n\njulia> @gap \"[1,,2]\"\nGAP: [ 1,, 2 ]\n\njulia> @gap \"(1,2)(3,4)\"\nGAP: (1,2)(3,4)\n\n\n\n\n\n\n","category":"macro"},{"location":"other/#GAP.@g_str","page":"Other stuff","title":"GAP.@g_str","text":"@g_str\n\nCreate a GAP string by typing g\"content\".\n\nExamples\n\njulia> g\"foo\"\nGAP: \"foo\"\n\njulia> g\"ab\\ncd\\\"ef\\\\gh\"   # special characters are handled as in GAP\nGAP: \"ab\\ncd\\\"ef\\\\gh\"\n\n\nDue to Julia's way of handing over arguments into the code of macros, not all strings representing valid GAP strings can be processed.\n\njulia> g\"\\\\\"\nERROR: Error thrown by GAP: Syntax error: String must end with \" before end of file in stream:1\n[...]\n\n\nConversely, there are valid arguments for the macro that are not valid Julia strings.\n\njulia> g\"\\c\"\nGAP: \"\\c\"\n\n\n\n\n\n\n","category":"macro"},{"location":"other/#GAP.@include","page":"Other stuff","title":"GAP.@include","text":"GAP.@include(path)\n\nRead and execute the GAP code in the file at path.\n\nNote that path  must be either an absolute path or a path relative to the file where this macro is used. This is similar to julia's built-in include function, but for GAP code instead of Julia code.\n\n\n\n\n\n","category":"macro"},{"location":"other/#GAP.@gapwrap","page":"Other stuff","title":"GAP.@gapwrap","text":"@gapwrap\n\nWhen applied to a method definition that involves access to entries of GAP.Globals, this macro rewrites the code such that the relevant GAP globals are cached, and need not be fetched again and again.\n\nExamples\n\njulia> @gapwrap isevenint(x) = GAP.Globals.IsEvenInt(x)::Bool;\n\njulia> isevenint(1)\nfalse\n\njulia> isevenint(2)\ntrue\n\n\n\n\n\n\n","category":"macro"},{"location":"other/#GAP.@gapattribute","page":"Other stuff","title":"GAP.@gapattribute","text":"@gapattribute\n\nThis macro is intended to be applied to a method definition for a unary function called attr, say, where the argument has the type T, say, the code contains exactly one call of the form GAP.Globals.Something(X), where Something is a GAP attribute such as Centre or IsSolvableGroup, and attr returns the corresponding attribute value for its argument.\n\nThe macro defines three functions attr, has_attr, and set_attr, where attr takes an argument of type T and returns what the given method definition says, has_attr takes an argument of type T and returns the result of GAP.Globals.HasSomething(X) (which is either true or false), set_attr takes an argument of type T and an object obj and calls GAP.Globals.SetSomething(X, obj).\n\nIn order to avoid runtime access via GAP.Globals.Something etc., the same modifications are applied in the construction of the three functions that are applied by @gapwrap.\n\nThe variables that are created by the macro belong to the Julia module in whose scope the macro is called.\n\nExamples\n\njulia> @gapattribute isstrictlysortedlist(obj::GapObj) = GAP.Globals.IsSSortedList(obj)::Bool;\n\njulia> l = GapObj([ 1, 3, 7 ]);\n\njulia> has_isstrictlysortedlist( l )\nfalse\n\njulia> isstrictlysortedlist( l )\ntrue\n\njulia> has_isstrictlysortedlist( l )\ntrue\n\njulia> l = GapObj([ 1, 3, 7 ]);\n\njulia> has_isstrictlysortedlist( l )\nfalse\n\njulia> set_isstrictlysortedlist( l, true )\n\njulia> has_isstrictlysortedlist( l )\ntrue\n\njulia> isstrictlysortedlist( l )\ntrue\n\n\n\n\n\n\n","category":"macro"},{"location":"other/#GAP.@wrap","page":"Other stuff","title":"GAP.@wrap","text":"@wrap funcdecl\n\nWhen applied to a function declaration of the form NAME(a::T) or NAME(a::T)::S, this macro generates a function which behaves equivalently to NAME(a::T) = GAP.Globals.NAME(a) resp. NAME(a::T) = GAP.Globals.NAME(a)::S, assuming that GAP.Globals.NAME references a GAP function. Function declarations with more than one argument or zero arguments are also supported.\n\nHowever, the generated function actually caches the GAP object GAP.Globals.NAME. This minimizes the call overhead. So @wrap typically is used to provide an optimized way to call certain GAP functions.\n\nIf an argument is annotated as ::GapObj (respectively ::GAP.Obj or ::GapInt), the resulting function accepts arguments of any type and attempts to convert them to GapObj (respectively GAP.Obj or GapInt) before passing them to the GAP function.\n\nAnother use case for this macro is to improve type stability of code calling into GAP, via the type annotations for the arguments and return value contained in the function declaration.\n\nBe advised, though, that if the value of GAP.Globals.NAME is changed later on, the function generated by this macro will not be updated, i.e., it will still reference the original GAP object.\n\nExamples\n\njulia> GAP.@wrap IsString(x::GapObj)::Bool\nIsString (generic function with 1 method)\n\njulia> IsString(\"abc\")\ntrue\n\njulia> GAP.@wrap Jacobi(x::GapInt, y::GapInt)::Int\nJacobi (generic function with 1 method)\n\njulia> Jacobi(11,35)\n1\n\njulia> Jacobi(big(35)^100+11, 35)\n1\n\n\n\n\n\n","category":"macro"},{"location":"other/#GAP.@install","page":"Other stuff","title":"GAP.@install","text":"@install\n\nWhen applied to a unary method definition for the function GapObj, with argument of type T, this macro installs instead a three argument method for GAP.GapObj_internal, with second argument of type GAP.GapCacheDict and third argument of type Bool.\n\nThis way, the intended GapObj(x::T) method becomes available, and additionally its code is applicable in recursive calls, for example when GapObj is called with a vector of objects of type T.\n\nSince the GapObj method does not support a dictionary for tracking identical subobjects, the type T is marked as \"not needing recursion\", by automatically installing a method for _needs_tracking_julia_to_gap that returns false.\n\nThe calls of the macro have the form GAP.@install GapObj(x::T) = f(x) or GAP.@install function GapObj(x::T) ... end.\n\n\n\n\n\n","category":"macro"},{"location":"other/#GAP.call_gap_func","page":"Other stuff","title":"GAP.call_gap_func","text":"call_gap_func(func::GapObj, args...; kwargs...)\n\nCall the GAP object func as a function, with arguments args... and global GAP options kwargs..., and return the result if there is one, and nothing otherwise.\n\nThere is no argument number checking here, all checks on the arguments are done by GAP itself.\n\nFor convenience, one can use the syntax func(args...; kwargs...).\n\nExamples\n\njulia> GAP.Globals.Factors( 12 )\nGAP: [ 2, 2, 3 ]\n\njulia> GAP.Globals.Cyc(GAP.Obj(1.41421356))\nGAP: 35355339/25000000\n\njulia> GAP.Globals.Cyc(GAP.Obj(1.41421356); bits=20)\nGAP: E(8)-E(8)^3\n\n\n\n\n\n","category":"function"},{"location":"other/#GAP.call_with_catch","page":"Other stuff","title":"GAP.call_with_catch","text":"call_with_catch(func, args::Vector)\ncall_with_catch(func, args::Vector, kwargs::Dict{Symbol,T}) where T\n\nReturn a tuple (ok, val) representing the outcome of calling func with arguments args (and optionally with keyword arguments given by the keys and values of kwargs).\n\nHere ok is either true, meaning that calling func returned the value val, or false, meaning that the function call did run into an error. In the latter case, val is set to the string of the error message.\n\nThis function is used on the GAP side.\n\nExamples\n\njulia> GAP.call_with_catch(sqrt, [2])\n(true, 1.4142135623730951)\n\njulia> flag, res = GAP.call_with_catch(sqrt, [-2]);\n\njulia> flag\nfalse\n\njulia> startswith(res, \"DomainError\")\ntrue\n\njulia> GAP.call_with_catch(range, [2, 10], Dict(:step => 2))\n(true, 2:2:10)\n\njulia> flag, res = GAP.call_with_catch(range, [2, 10], Dict(:step => \"a\"));\n\njulia> flag\nfalse\n\njulia> startswith(res, \"MethodError\")\ntrue\n\n\n\n\n\n","category":"function"},{"location":"other/#Base.getindex","page":"Other stuff","title":"Base.getindex","text":"getindex(x::GapObj, i::Int64)\ngetindex(x::GapObj, i::Int64, j::Int64)\ngetindex(x::GapObj, l::Union{Vector{T},AbstractRange{T}}) where {T<:Integer}\n\nReturn the entry at position i or at position (i,j) in x, or the list of entries in x at the positions described by l, provided that x is a GAP object supporting this, such as a GAP list or matrix object.\n\nExamples\n\njulia> l = GapObj([ 1, 2, 3, 5, 8, 13 ])\nGAP: [ 1, 2, 3, 5, 8, 13 ]\n\njulia> l[4]\n5\n\njulia> l[end]\n13\n\njulia> l[2:4]\nGAP: [ 2, 3, 5 ]\n\njulia> l[[1,4,4]]\nGAP: [ 1, 5, 5 ]\n\njulia> m = GapObj([ 1 2 ; 3 4 ])\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\njulia> m[1,1]\n1\n\njulia> m[1,2]\n2\n\njulia> m[2,1]\n3\n\n\n\n\n\n","category":"function"},{"location":"other/#Base.setindex!","page":"Other stuff","title":"Base.setindex!","text":"setindex!(x::GapObj, v::Any, i::Int64)\nsetindex!(x::GapObj, v::Any, i::Int64, j::Int64)\nsetindex!(x::GapObj, v::Any, l::Union{Vector{T},AbstractRange{T}}) where {T<:Integer}\n\nSet the entry at position i or (i,j) in x to v, or set the entries at the positions in x that are described by l to the entries in v, provided that x is a GAP object supporting this, such as a GAP list or matrix object.\n\nExamples\n\njulia> l = GapObj([ 1, 2, 3, 5, 8, 13 ])\nGAP: [ 1, 2, 3, 5, 8, 13 ]\n\njulia> l[1] = 0\n0\n\njulia> l[8] = -1\n-1\n\njulia> l[2:4] = [ 7, 7, 7 ]\n3-element Vector{Int64}:\n 7\n 7\n 7\n\njulia> l\nGAP: [ 0, 7, 7, 7, 8, 13,, -1 ]\n\njulia> m = GapObj([ 1 2 ; 3 4 ])\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\njulia> m[1,2] = 0\n0\n\njulia> m\nGAP: [ [ 1, 0 ], [ 3, 4 ] ]\n\n\n\n\n\n","category":"function"},{"location":"other/#GAP.getbangindex","page":"Other stuff","title":"GAP.getbangindex","text":"getbangindex(x::GapObj, i::Int64)\n\nReturn the entry at position i in the positional object x.\n\nExamples\n\njulia> x = GAP.Globals.ZmodnZObj(1, 6)\nGAP: ZmodnZObj( 1, 6 )\n\njulia> GAP.Globals.IsPositionalObjectRep(x)\ntrue\n\njulia> getbangindex(x, 1)\n1\n\n\n\n\n\n","category":"function"},{"location":"other/#GAP.hasbangindex","page":"Other stuff","title":"GAP.hasbangindex","text":"hasbangindex(x::GapObj, i::Int64)\n\nReturn whether the entry at position i exists in the positional object x.\n\nExamples\n\njulia> x = GAP.Globals.ZmodnZObj(1, 6)\nGAP: ZmodnZObj( 1, 6 )\n\njulia> GAP.Globals.IsPositionalObjectRep(x)\ntrue\n\njulia> hasbangindex(x, 1)\ntrue\n\njulia> hasbangindex(x, 2)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"other/#GAP.setbangindex!","page":"Other stuff","title":"GAP.setbangindex!","text":"setbangindex!(x::GapObj, v::Any, i::Int64)\n\nSet the entry at position i in the positional object x to v, and return x.\n\nExamples\n\njulia> x = GAP.Globals.ZmodnZObj(1, 6)\nGAP: ZmodnZObj( 1, 6 )\n\njulia> GAP.Globals.IsPositionalObjectRep(x)\ntrue\n\njulia> setbangindex!(x, 0, 1)\nGAP: ZmodnZObj( 0, 6 )\n\n\n\n\n\n","category":"function"},{"location":"other/#Base.getproperty","page":"Other stuff","title":"Base.getproperty","text":"getproperty(x::GapObj, f::Symbol)\ngetproperty(x::GapObj, f::Union{AbstractString,Int64})\n\nReturn the record component of the GAP record x that is described by f.\n\nExamples\n\njulia> r = GapObj(Dict(:a => 1))\nGAP: rec( a := 1 )\n\njulia> r.a\n1\n\n\n\n\n\n","category":"function"},{"location":"other/#Base.setproperty!","page":"Other stuff","title":"Base.setproperty!","text":"setproperty!(x::GapObj, f::Symbol, v)\nsetproperty!(x::GapObj, f::Union{AbstractString,Int64}, v)\n\nSet the record component of the GAP record x that is described by f to the value v.\n\nExamples\n\njulia> r = GapObj(Dict(:a => 1))\nGAP: rec( a := 1 )\n\njulia> r.b = 0\n0\n\njulia> r\nGAP: rec( a := 1, b := 0 )\n\n\n\n\n\n","category":"function"},{"location":"other/#Base.hasproperty","page":"Other stuff","title":"Base.hasproperty","text":"hasproperty(x::GapObj, f::Symbol)\nhasproperty(x::GapObj, f::Union{AbstractString,Int64})\n\nReturn true if the GAP record x has a component that is described by f, and false otherwise.\n\nExamples\n\njulia> r = GapObj(Dict(:a => 1))\nGAP: rec( a := 1 )\n\njulia> hasproperty( r, :a )\ntrue\n\njulia> hasproperty( r, :b )\nfalse\n\njulia> r.b = 2\n2\n\njulia> hasproperty( r, :b )\ntrue\n\njulia> r\nGAP: rec( a := 1, b := 2 )\n\n\n\n\n\n","category":"function"},{"location":"other/#GAP.getbangproperty","page":"Other stuff","title":"GAP.getbangproperty","text":"getbangproperty(x::GapObj, f::Union{AbstractString,Int64,Symbol})\n\nReturn the value of the component f in the component object x.\n\nExamples\n\njulia> x = GAP.Globals.Iterator(GAP.Globals.Integers)\nGAP: <iterator of Integers at 0>\n\njulia> GAP.Globals.IsComponentObjectRep(x)\ntrue\n\njulia> getbangproperty(x, :counter)\n0\n\n\n\n\n\n","category":"function"},{"location":"other/#GAP.hasbangproperty","page":"Other stuff","title":"GAP.hasbangproperty","text":"hasbangproperty(x::GapObj, f::Union{AbstractString,Int64,Symbol})\n\nReturn whether the component object x has the component f.\n\nExamples\n\njulia> x = GAP.Globals.Iterator(GAP.Globals.Integers)\nGAP: <iterator of Integers at 0>\n\njulia> GAP.Globals.IsComponentObjectRep(x)\ntrue\n\njulia> hasbangproperty(x, :counter)\ntrue\n\njulia> hasbangproperty(x, :x)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"other/#GAP.setbangproperty!","page":"Other stuff","title":"GAP.setbangproperty!","text":"setbangproperty!(x::GapObj, f::Union{AbstractString,Int64,Symbol}, v)\n\nSet the value of the component f in the component object x to v, and return x.\n\nExamples\n\njulia> x = GAP.Globals.Iterator(GAP.Globals.Integers)\nGAP: <iterator of Integers at 0>\n\njulia> GAP.Globals.IsComponentObjectRep(x)\ntrue\n\njulia> setbangproperty!(x, :counter, 3)\nGAP: <iterator of Integers at -1>\n\njulia> getbangproperty(x, :counter)\n3\n\n\n\n\n\n","category":"function"},{"location":"other/#GAP.wrap_rng","page":"Other stuff","title":"GAP.wrap_rng","text":"wrap_rng(rng::Random.AbstractRNG)\n\nReturn a GAP object in the filter IsRandomSource that uses rng in calls to GAP's Random function. The idea is that GAP's Random methods for high level objects will just hand over the given random source to subfunctions until Random gets called for a list or the bounds of a range, and then Base.rand gets called with rng.\n\nExamples\n\njulia> rng1 = Random.default_rng();\n\njulia> rng2 = copy(rng1);\n\njulia> rng1 == rng2\ntrue\n\njulia> rng1 === rng2\nfalse\n\njulia> gap_rng1 = GAP.wrap_rng(rng1)\nGAP: <RandomSource in IsRandomSourceJulia>\n\njulia> gap_rng2 = GAP.wrap_rng(rng2)\nGAP: <RandomSource in IsRandomSourceJulia>\n\njulia> res1 = GAP.Globals.Random(gap_rng1, 1, 10);\n\njulia> rng1 == rng2   # the two rngs have diverged\nfalse\n\njulia> res1 == GAP.Globals.Random(gap_rng2, GapObj(1:10))\ntrue\n\njulia> rng1 == rng2   # now the two rngs are again in sync\ntrue\n\njulia> g = GAP.Globals.SymmetricGroup(10);\n\njulia> p = GAP.Globals.Random(gap_rng1, g);\n\njulia> p in g\ntrue\n\njulia> GAP.Globals.Random(gap_rng1, GAP.Globals.GF(2)^10)\nGAP: <a GF2 vector of length 10>\n\n\n\n\n\n","category":"function"},{"location":"other/#GAP.randseed!","page":"Other stuff","title":"GAP.randseed!","text":"GAP.randseed!([seed::Integer])\n\nReseed GAP's global RNG with seed.\n\nThe given seed must be a non-negative integer. When seed is not specified, a random seed is generated from Julia's global RNG.\n\nFor a fixed seed, the stream of generated numbers is allowed to change between different versions of GAP.\n\n\n\n\n\n","category":"function"},{"location":"other/#GAP.show_gap_help","page":"Other stuff","title":"GAP.show_gap_help","text":"show_gap_help(topic::String, onlyexact::Bool = false)\n\nPrint the information from the GAP help system about topic to the screen.\n\nIf onlyexact is true then only exact matches are shown, otherwise all matches. For example, GAP.show_gap_help(\"Size\") shows also documentation for SizeScreen and SizesPerfectGroups, whereas GAP.show_gap_help(\"Size\", true) shows only documentation for Size.\n\nFor the variant showing all matches, one can also enter ?GAP.Globals.Size at the Julia prompt instead of calling show_gap_help.\n\nExamples\n\njulia> GAP.show_gap_help( \"Size\" )\n[...]  # more than 50 entries from GAP manuals\n\nhelp?> GAP.Globals.Size\n[...]  # the same\n\njulia> GAP.show_gap_help( \"Size\", true )\n[...]  # about 15 entries from GAP manuals\n\n\n\n\n\n\n","category":"function"},{"location":"packages/#Managing-GAP-packages","page":"Managing GAP packages","title":"Managing GAP packages","text":"The following functions allow one to load/install/update/remove/locate GAP packages.","category":"section"},{"location":"packages/#GAP.Packages.load","page":"Managing GAP packages","title":"GAP.Packages.load","text":"load(spec::String, version::String = \"\";\n         install::Union{Bool, String} = false,\n         quiet::Bool = true)\n\nTry to load the GAP package given by spec, which can be either the name of the package or a local path where the package is installed (a directory that contains the package's PackageInfo.g file).\n\nIf version is specified then try to load a version of the package that is compatible with version, in the sense of GAP's CompareVersionNumbers function, otherwise try to load the newest installed version. Return true if this is successful, and false otherwise.\n\nIf install is set to true or to a string and (the desired version of) the required GAP package is not yet installed and spec is the package name then install is called first, in order to install the package; if no version is prescribed then the newest released version of the package will be installed. A string value of install can be the URL of an archive or repository containing a package, or the URL of a PackageInfo.g file, like the first argument of install.\n\nThe function calls GAP's LoadPackage function. If quiet is set to false then package banners are shown for all packages being loaded. The quiet value is also passed on to install.\n\n\n\n\n\n","category":"function"},{"location":"packages/#GAP.Packages.install","page":"Managing GAP packages","title":"GAP.Packages.install","text":"install(spec::String, version::String = \"\";\n        interactive::Bool = true,\n        quiet::Bool = false,\n        debug::Bool = false,\n        pkgdir::AbstractString = GAP.Packages.DEFAULT_PKGDIR[])\n\nDownload and install the GAP package given by spec into the pkgdir directory.\n\nspec can be either the name of a package or the URL of an archive or repository containing a package, or the URL of a PackageInfo.g file.\n\nIf spec is the name of a package then the package version can be specified by version, in the format described for GAP's CompareVersionNumbers function. In all other cases the newest released version of the package will get installed.\n\nReturn true if the installation is successful or if (a version compatible with version) of the package was already installed, and false otherwise.\n\nThe function uses the function InstallPackage from GAP's package PackageManager. The info messages shown by this function can be suppressed by passing true as the value of quiet. Specifying interactive = false will prevent PackageManager from prompting the user for input interactively. For details, please refer to its documentation.\n\n\n\n\n\n","category":"function"},{"location":"packages/#GAP.Packages.update","page":"Managing GAP packages","title":"GAP.Packages.update","text":"update(spec::String;\n       interactive::Bool = true,\n       quiet::Bool = false,\n       debug::Bool = false,\n       pkgdir::AbstractString = GAP.Packages.DEFAULT_PKGDIR[])\n\nUpdate the GAP package given by spec that is installed in the pkgdir directory, to the latest version. Return true if a newer version was installed successfully, or if no newer version is available, and false otherwise.\n\nspec can be either the name of a package or the URL of an archive or repository containing a package, or the URL of a PackageInfo.g file.\n\nThe function uses the function UpdatePackage from GAP's package PackageManager. The info messages shown by this function can be suppressed by passing true as the value of quiet. Specifying interactive = false will prevent PackageManager from prompting the user for input interactively. For details, please refer to its documentation.\n\n\n\n\n\n","category":"function"},{"location":"packages/#GAP.Packages.remove","page":"Managing GAP packages","title":"GAP.Packages.remove","text":"remove(spec::String;\n       interactive::Bool = true,\n       quiet::Bool = false,\n       debug::Bool = false,\n       pkgdir::AbstractString = GAP.Packages.DEFAULT_PKGDIR[])\n\nRemove the GAP package with name spec that is installed in the pkgdir directory. Return true if the removal was successful, and false otherwise.\n\nThe function uses the function RemovePackage from GAP's package PackageManager. The info messages shown by this function can be suppressed by passing true as the value of quiet. Specifying interactive = false will prevent PackageManager from prompting the user for input interactively. For details, please refer to its documentation.\n\n\n\n\n\n","category":"function"},{"location":"packages/#GAP.Packages.build","page":"Managing GAP packages","title":"GAP.Packages.build","text":"build(name::String;\n      quiet::Bool = false,\n      debug::Bool = false,\n      pkgdir::AbstractString = GAP.Packages.DEFAULT_PKGDIR[])\n\nBuild the GAP package with name name that is installed in the pkgdir directory.\n\nIf no package with name name is installed in pkgdir but there is a version of name bundled with the GAP package distro, this version is copied to pkgdir and built.\n\nReturn true if the build was successful or the package was already built, and false otherwise.\n\nThe function uses the function CompilePackage from GAP's package PackageManager. The info messages shown by this function can be suppressed by passing true as the value of quiet.\n\n\n\n\n\n","category":"function"},{"location":"packages/#GAP.Packages.build_recursive","page":"Managing GAP packages","title":"GAP.Packages.build_recursive","text":"build_recursive(name::String;\n                quiet::Bool = false,\n                debug::Bool = false,\n                pkgdir::AbstractString = GAP.Packages.DEFAULT_PKGDIR[])\n\nBuild the GAP package with name name that is installed in the pkgdir directory, as well as all of its (transitive) dependencies.\n\nThis is achieved by calling build for the package name and then all of its NeededOtherPackages, recursively. All keyword arguments are passed on to build.\n\n\n\n\n\n","category":"function"},{"location":"packages/#GAP.Packages.test","page":"Managing GAP packages","title":"GAP.Packages.test","text":"test(name::String)\n\nRun the tests of GAP package name and return a boolean indicating whether they succeeded (true) or not.\n\nIt is intended to be used with the @test macro from the Test package.\n\nThe function uses the GAP function TestPackage.\n\n\n\n\n\n","category":"function"},{"location":"packages/#GAP.Packages.locate_package","page":"Managing GAP packages","title":"GAP.Packages.locate_package","text":"locate_package(name::String)\n\nReturn the path where the GAP package with name name is installed if this package is loaded, and \"\" otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#GAP.jl","page":"GAP.jl","title":"GAP.jl","text":"","category":"section"},{"location":"#Introduction","page":"GAP.jl","title":"Introduction","text":"GAP.jl is a low level interface from Julia to the computer algebra system GAP. The term \"low level\" means that the aim is to give Julia access to all GAP objects, to let Julia call GAP functions, and to provide conversions of low level data (integers, Booleans, strings, arrays/lists, dictionaries/records) between the two systems.\n\nIn particular, it is not the aim of GAP.jl to provide Julia types for higher level GAP objects that represent algebraic structures, such as groups, rings, fields, etc., and mappings between such structures.\n\nThe connection between GAP and Julia is in fact bidirectional, that is, GAP can access all Julia objects, call Julia functions, and perform conversions of low level data. This direction will become interesting on the Julia side as soon as GAP packages provide functionality that is based on using Julia code from the GAP side.\n\nThe viewpoint of an interface from GAP to Julia is described in the manual of the GAP package JuliaInterface.","category":"section"},{"location":"#Acknowledgements","page":"GAP.jl","title":"Acknowledgements","text":"The development of this Julia package has been supported by the German Research Foundation (DFG) within the Collaborative Research Center TRR 195 Symbolic Tools in Mathematics and their Applications (from 2017 until 2028).","category":"section"},{"location":"#Table-of-contents","page":"GAP.jl","title":"Table of contents","text":"Pages = GAP.GAP_docs_pages","category":"section"}]
}
