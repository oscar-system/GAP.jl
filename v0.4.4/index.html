<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>GAP.jl · GAP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script data-main="assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><h1>GAP.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="search/" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li class="current"><a class="toctext" href="">GAP.jl</a><ul class="internal"><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Macros-1">Macros</a></li><li><a class="toctext" href="#Conversions-1">Conversions</a></li><li><a class="toctext" href="#Convenience-adapters-1">Convenience adapters</a></li><li><a class="toctext" href="#Access-to-the-GAP-help-system-1">Access to the GAP help system</a></li><li><a class="toctext" href="#Managing-GAP-packages-1">Managing GAP packages</a></li><li><a class="toctext" href="#Other-1">Other</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="">GAP.jl</a></li></ul><a class="edit-page" href="https://github.com/oscar-system/GAP.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>GAP.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#GAP.jl-1" id="GAP.jl-1">GAP.jl</a></h1><ul><li><a href="#GAP.jl-1">GAP.jl</a></li><ul><li><a href="#Introduction-1">Introduction</a></li><li><a href="#Types-1">Types</a></li><li><a href="#Macros-1">Macros</a></li><li><a href="#Conversions-1">Conversions</a></li><li><a href="#Convenience-adapters-1">Convenience adapters</a></li><li><a href="#Access-to-the-GAP-help-system-1">Access to the GAP help system</a></li><li><a href="#Managing-GAP-packages-1">Managing GAP packages</a></li><li><a href="#Other-1">Other</a></li><li><a href="#Index-1">Index</a></li></ul></ul><h2><a class="nav-anchor" href="#Introduction-1" id="Introduction-1">Introduction</a></h2><p>GAP.jl is a low level interface from Julia to <a href="https://www.gap-system.org">the computer algebra system GAP</a>. The term "low level" means that the aim is to give Julia access to all GAP objects, to let Julia call GAP functions, and to provide conversions of low level data (integers, Booleans, strings, arrays/lists, dictionaries/records) between the two systems.</p><p>In particular, it is <em>not</em> the aim of GAP.jl to provide Julia types for higher level GAP objects that represent algebraic structures, such as groups, rings, fields, etc., and mappings between such structures.</p><p>The connection between GAP and Julia is in fact bidirectional, that is, GAP can access all Julia objects, call Julia functions, and perform conversions of low level data. This direction will become interesting on the Julia side as soon as GAP packages provide functionality that is based on using Julia code from the GAP side.</p><p>The viewpoint of an interface from GAP to Julia is described in <a href="GAP_ref(JuliaInterface:Title page)">the manual of the GAP package JuliaInterface</a>.</p><h2><a class="nav-anchor" href="#Types-1" id="Types-1">Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#GAP.FFE" id="GAP.FFE"><code>GAP.FFE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FFE</code></pre><p>Wrap a pointer to a GAP FFE ("finite field element") immediate object. This type is defined in the JuliaInterface C code.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = GAP.evalstr( "Z(3)" )
GAP: Z(3)

julia&gt; typeof( x )
FFE
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#GAP.GapObj" id="GAP.GapObj"><code>GAP.GapObj</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GapObj</code></pre><p>This is the Julia type of all those GAP objects that are not "immediate" (Booleans, small integers, FFEs).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isa( GAP.evalstr( "[ 1, 2 ]" ), GapObj ) # a GAP list
true

julia&gt; isa( GAP.evalstr( "rec()" ), GapObj )    # a GAP record
true

julia&gt; isa( GAP.evalstr( "(1,2,3)" ), GapObj )  # a GAP permutation
true

julia&gt; isa( GAP.evalstr( "2^64" ), GapObj )     # a large GAP integer
true

julia&gt; typeof( GAP.evalstr( "2^59" ) )          # a small GAP integer
Int64

julia&gt; typeof( GAP.evalstr( "Z(2)" ) )          # a GAP FFE
FFE

julia&gt; typeof( GAP.evalstr( "true" ) )          # a Boolean
Bool
</code></pre><p>Note that this is Julia's viewpoint on GAP objects. From the viewpoint of GAP, also the pointers to Julia objects are implemented as "non-immediate GAP objects", but they appear as Julia objects to Julia, not "doubly wrapped".</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; GAP.evalstr( "Julia.Base" )
Base

julia&gt; typeof( GAP.evalstr( "Julia.Base" ) )        # native Julia object
Module
</code></pre><p>One can use <code>GapObj</code> as a constructor, in order to convert Julia objects to GAP objects. Such calls are delegated to <a href="#GAP.julia_to_gap"><code>julia_to_gap</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; GapObj(1//3)
GAP: 1/3

julia&gt; GapObj([1 2; 3 4])
GAP: [ [ 1, 2 ], [ 3, 4 ] ]
</code></pre></div></div></section><h2><a class="nav-anchor" href="#Macros-1" id="Macros-1">Macros</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#GAP.@gap" id="GAP.@gap"><code>GAP.@gap</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@gap &lt;expr&gt;
@gap(&lt;expr&gt;)</code></pre><p>Execute &lt;expr&gt; directly in GAP, as if <code>GAP.evalstr("&lt;expr&gt;")</code> was called. This can be used for creating GAP literals directly from Julia.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @gap [1,2,3]
GAP: [ 1, 2, 3 ]

julia&gt; @gap SymmetricGroup(3)
GAP: Sym( [ 1 .. 3 ] )

julia&gt; @gap(SymmetricGroup)(3)
GAP: Sym( [ 1 .. 3 ] )
</code></pre><p>Note that the last two examples have a slight syntactical, and therefore also a semantical difference. The first one executes the string <code>SymmetricGroup(3)</code> directly inside GAP. The second example returns the function <code>SymmetricGroup</code> via <code>@gap(SymmetricGroup)</code>, then calls that function with the argument <code>3</code>.</p><p>Due to Julia's way of handing over arguments into the code of macros, not all expressions representing valid GAP code can be processed. For example, the GAP syntax of permutations consisting of more than one cycle cause problems, as well as the GAP syntax of non-dense lists.</p><pre><code class="language-julia-repl">julia&gt; @gap (1,2,3)
GAP: (1,2,3)

julia&gt; @gap (1,2)(3,4)
ERROR: LoadError: Error thrown by GAP: Error, no method found! For debugging hints type ?Recovery from NoMethodFound
[...]

julia&gt; @gap [ 1,, 2 ]
ERROR: syntax: unexpected ","
[...]
</code></pre><p>Note also that a string argument gets evaluated with <code>GAP.evalstr</code>.</p><pre><code class="language-julia-repl">julia&gt; @gap "\"abc\""
GAP: "abc"

julia&gt; @gap "[1,,2]"
GAP: [ 1,, 2 ]

julia&gt; @gap "(1,2)(3,4)"
GAP: (1,2)(3,4)
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#GAP.@g_str" id="GAP.@g_str"><code>GAP.@g_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@g_str</code></pre><p>Create a GAP string by typing <code>g"content"</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g"foo"
GAP: "foo"</code></pre></div></div></section><h2><a class="nav-anchor" href="#Conversions-1" id="Conversions-1">Conversions</a></h2><p>One of the main ideas of GAP.jl is that automatic conversions of Julia objects to GAP objects and vice versa shall be avoided whenever this is possible. For a few types of objects, such conversions are unavoidable, see <a href="#Automatic-GAP-to-Julia-and-Julia-to-GAP-Conversions-1">Automatic GAP-to-Julia and Julia-to-GAP Conversions</a>. In all other situations, the conversions between GAP objects and corresponding Julia objects can be performed using <a href="#GAP.gap_to_julia"><code>gap_to_julia</code></a> and <a href="#GAP.julia_to_gap"><code>julia_to_gap</code></a>, or using <code>Base.convert</code>, see <a href="#Explicit-GAP-to-Julia-and-Julia-to-GAP-Conversions-1">Explicit GAP-to-Julia and Julia-to-GAP Conversions</a>, respectively.</p><p>For convenience, also constructor methods are provided, for example <code>Vector{Int64}(obj)</code> can be used instead of <code>GAP.gap_to_julia(Vector{Int64}, obj)</code>, where <code>obj</code> is a GAP list of integers; see <a href="#Constructor-Methods-for-GAP-to-Julia-Conversions-1">Constructor Methods for GAP-to-Julia Conversions</a> for a description of these methods. For Julia-to-GAP conversions, one can use for example <code>GapObj(obj)</code>, where <code>obj</code> is a Julia object, see <a href="#GAP.GapObj"><code>GapObj</code></a>.</p><h3><a class="nav-anchor" href="#Automatic-GAP-to-Julia-and-Julia-to-GAP-Conversions-1" id="Automatic-GAP-to-Julia-and-Julia-to-GAP-Conversions-1">Automatic GAP-to-Julia and Julia-to-GAP Conversions</a></h3><p>When one calls a GAP function with Julia objects as arguments, or a Julia function with GAP objects as arguments, the arguments are in general not automatically converted to GAP objects or Julia objects, respectively. The exceptions are as follows.</p><ul><li><p>GAP's immediate integers (in the range -2^60 to 2^60-1) are automatically converted to Julia's <code>Int64</code> objects; Julia's <code>Int64</code> objects are automatically converted to GAP's immediate integers if they fit, and to GAP's large integers otherwise.</p></li><li><p>GAP's immediate finite field elements are automatically converted to Julia's <code>GAP.FFE</code> objects, and vice versa.</p></li><li><p>GAP's <code>true</code> and <code>false</code> are automatically converted to Julia's <code>true</code> and <code>false</code>, and vice versa.</p></li></ul><h3><a class="nav-anchor" href="#Explicit-GAP-to-Julia-and-Julia-to-GAP-Conversions-1" id="Explicit-GAP-to-Julia-and-Julia-to-GAP-Conversions-1">Explicit GAP-to-Julia and Julia-to-GAP Conversions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#GAP.gap_to_julia" id="GAP.gap_to_julia"><code>GAP.gap_to_julia</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">gap_to_julia(type, x, recursion_dict=nothing; recursive=true)</code></pre><p>Try to convert the object <code>x</code> to a Julia object of type <code>type</code>. If <code>x</code> is a <code>GAP.GapObj</code> then the conversion rules are defined in the manual of the GAP package JuliaInterface. If <code>x</code> is another <code>GAP.Obj</code> (for example a <code>Int64</code>) then the result is defined in Julia by <code>type</code>.</p><p>The parameter <code>recursion_dict</code> is meant to preseve the identity of converted subobjects and should never be given by the user.</p><p>For GAP lists and records, it makes sense to convert also the subobjects recursively, or to keep the subobjects as they are; the behaviour is controlled by <code>recursive</code>, which can be <code>true</code> or <code>false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; GAP.gap_to_julia( GAP.evalstr( "1/3" ) )
1//3

julia&gt; GAP.gap_to_julia( GAP.evalstr( "\"abc\"" ) )
"abc"

julia&gt; val = GAP.evalstr( "[ [ 1, 2 ], [ 3, 4 ] ]" );

julia&gt; GAP.gap_to_julia( val )
2-element Array{Any,1}:
 Any[1, 2]
 Any[3, 4]

julia&gt; GAP.gap_to_julia( val, recursive = false )
2-element Array{Any,1}:
 GAP: [ 1, 2 ]
 GAP: [ 3, 4 ]
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#GAP.julia_to_gap" id="GAP.julia_to_gap"><code>GAP.julia_to_gap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">julia_to_gap(input, recursion_dict = IdDict(); recursive = false)</code></pre><p>Convert a julia object <code>input</code> to an appropriate GAP object. If <code>recursive</code> is set to <code>true</code>, recursive conversions on arrays, tuples, and dictionaries is performed.</p><p>The input <code>recursion_dict</code> should never be set by the user, it is meant to keep egality of input data, by converting egal data to identical objects in GAP.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; GAP.julia_to_gap(1//3)
GAP: 1/3

julia&gt; GAP.julia_to_gap("abc")
GAP: "abc"

julia&gt; GAP.julia_to_gap([ [1, 2], [3, 4]])
GAP: [ &lt;Julia: [1, 2]&gt;, &lt;Julia: [3, 4]&gt; ]

julia&gt; GAP.julia_to_gap([ [1, 2], [3, 4]], recursive = true)
GAP: [ [ 1, 2 ], [ 3, 4 ] ]
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.convert" id="Base.convert"><code>Base.convert</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">convert(T, obj::GapObj; recursive::Bool = true)</code></pre><p>Return the Julia object of type <code>T</code> that corresponds to <code>obj</code>. If <code>recursive</code> is <code>true</code> then subobjects of <code>obj</code> are also converted, otherwise not. Such calls are delegated to <a href="#GAP.gap_to_julia"><code>gap_to_julia</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = @gap 2^64
GAP: 18446744073709551616

julia&gt; convert(Rational{BigInt}, val)
18446744073709551616//1

julia&gt; val = @gap [ [ 1 ], [ 2 ] ]
GAP: [ [ 1 ], [ 2 ] ]

julia&gt; convert(Vector{Any}, val)
2-element Array{Any,1}:
 Any[1]
 Any[2]

julia&gt; convert(Vector{Any}, val, recursive = false)
2-element Array{Any,1}:
 GAP: [ 1 ]
 GAP: [ 2 ]
</code></pre></div></div><div><div><pre><code class="language-none">convert(GapObj, obj; recursive = false)</code></pre><p>Return the GAP object that corresponds to the Julia object <code>obj</code>. If <code>recursive</code> is <code>true</code> then subobjects of <code>obj</code> are also converted, otherwise not.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; convert( GapObj, [1 2; 3 4] )
GAP: [ [ 1, 2 ], [ 3, 4 ] ]

julia&gt; convert( GapObj, [[1, 2], [3, 4]] )
GAP: [ &lt;Julia: [1, 2]&gt;, &lt;Julia: [3, 4]&gt; ]

julia&gt; convert( GapObj, [[1, 2], [3, 4]], recursive = true )
GAP: [ [ 1, 2 ], [ 3, 4 ] ]
</code></pre></div></div></section><h3><a class="nav-anchor" href="#Constructor-Methods-for-GAP-to-Julia-Conversions-1" id="Constructor-Methods-for-GAP-to-Julia-Conversions-1">Constructor Methods for GAP-to-Julia Conversions</a></h3><p>(For Julia-to-GAP conversions, one can use <a href="#GAP.GapObj"><code>GapObj</code></a> as a constructor.)</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Core.Int128" id="Core.Int128"><code>Core.Int128</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Int128(obj::GapObj)</code></pre><p>Return the <code>Int128</code> converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap14.html#X853DF11B80068ED5">GAP integer</a><code>obj</code>. (Note that small GAP integers are represented by Julia <code>Int64</code> objects, in particular they are not <code>GapObj</code>s; their conversion is not handled by methods installed in GAP.jl.)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr("2^80")
GAP: 1208925819614629174706176

julia&gt; Int128(val)
1208925819614629174706176
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.GMP.BigInt" id="Base.GMP.BigInt"><code>Base.GMP.BigInt</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BigInt(obj::GapObj)</code></pre><p>Return the big integer converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap14.html#X853DF11B80068ED5">GAP integer</a><code>obj</code>. (Note that small GAP integers are not represented by <code>GapObj</code>s, their conversion with <code>BigInt</code> is handled by Julia's methods.)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr("2^64")
GAP: 18446744073709551616

julia&gt; BigInt(val)
18446744073709551616

julia&gt; val = GAP.evalstr("2^59")
576460752303423488

julia&gt; isa(val, GapObj)
false

julia&gt; BigInt(val)
576460752303423488
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.Rational" id="Base.Rational"><code>Base.Rational</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Rational{T}(obj::GapObj) where {T&lt;:Integer}</code></pre><p>Return the rational converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap14.html#X853DF11B80068ED5">GAP integer</a> or the <a href="https://www.gap-system.org/Manuals/doc/ref/chap17.html#X7B6029D18570C08A">GAP rational</a><code>obj</code>,</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr("2^64")
GAP: 18446744073709551616

julia&gt; Rational{Int128}(val)
18446744073709551616//1

julia&gt; Rational{BigInt}(val)
18446744073709551616//1

julia&gt; val = GAP.evalstr("1/3")
GAP: 1/3

julia&gt; Rational{Int64}(val)
1//3
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Core.Float64" id="Core.Float64"><code>Core.Float64</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Float64(obj::GapObj)</code></pre><p>Return the float converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap19.html#X81AA901181CA568F">GAP float</a><code>obj</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr("2.2")
GAP: 2.2

julia&gt; Float64(val)
2.2

julia&gt; Float32(val)
2.2f0
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.big" id="Base.big"><code>Base.big</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">big(obj::GapObj)</code></pre><p>Return the big integer converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap14.html#X853DF11B80068ED5">GAP integer</a><code>obj</code>, or the big rational converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap17.html#X7B6029D18570C08A">GAP rational</a><code>obj</code>, or the big float converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap19.html#X81AA901181CA568F">GAP float</a><code>obj</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr("2^64")
GAP: 18446744073709551616

julia&gt; big(val)
18446744073709551616

julia&gt; val = GAP.evalstr("1/3")
GAP: 1/3

julia&gt; big(val)
1//3

julia&gt; val = GAP.evalstr("1.1")
GAP: 1.1

julia&gt; big(val)
1.100000000000000088817841970012523233890533447265625
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Core.Char" id="Core.Char"><code>Core.Char</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Char(obj::GapObj)</code></pre><p>Return the character converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap27.html#X7D28329B7EDB8F47">GAP character</a><code>obj</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr("'x'")
GAP: 'x'

julia&gt; Char(val)
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.Cuchar" id="Base.Cuchar"><code>Base.Cuchar</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Cuchar(obj::GapObj)</code></pre><p>Return the <code>UInt8</code> that belongs to the <a href="https://www.gap-system.org/Manuals/doc/ref/chap27.html#X7D28329B7EDB8F47">GAP character</a><code>obj</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr("'x'")
GAP: 'x'

julia&gt; Cuchar(val)
0x78
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Core.String" id="Core.String"><code>Core.String</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">String(obj::GapObj)</code></pre><p>Return the Julia string converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap27.html#X7D28329B7EDB8F47">GAP string</a><code>obj</code>. Note that <a href="https://www.gap-system.org/Manuals/doc/ref/chap27.html#X81FB5BE27903EC32">GAP's String function</a> can be applied to arbitrary GAP objects, similar to Julia's <code>string</code> function; this behaviour is not intended for this <code>String</code> constructor.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr("\"abc\"")
GAP: "abc"

julia&gt; String(val)
"abc"

julia&gt; val = GAP.evalstr("[]")
GAP: [  ]

julia&gt; String(val)   # an empty GAP list is a string
""
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Core.Symbol" id="Core.Symbol"><code>Core.Symbol</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Symbol(obj::GapObj)</code></pre><p>Return the symbol converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap27.html#X7D28329B7EDB8F47">GAP string</a><code>obj</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; str = GAP.evalstr("\"abc\"")
GAP: "abc"

julia&gt; Symbol(str)
:abc
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.UnitRange" id="Base.UnitRange"><code>Base.UnitRange</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">UnitRange(obj::GapObj)</code></pre><p>Return the unit range converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap21.html#X79596BDE7CAF8491">GAP range</a><code>obj</code>, which has step width 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr("[ 1 .. 10 ]")
GAP: [ 1 .. 10 ]

julia&gt; UnitRange(val)
1:10

julia&gt; UnitRange{Int32}(val)
1:10
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.StepRange" id="Base.StepRange"><code>Base.StepRange</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StepRange(obj::GapObj)</code></pre><p>Return the step range converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap21.html#X79596BDE7CAF8491">GAP range</a><code>obj</code>, which may have arbitrary step width.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr("[ 1, 3 .. 11 ]")
GAP: [ 1, 3 .. 11 ]

julia&gt; StepRange(val)
1:2:11

julia&gt; r = StepRange{Int8,Int8}(val)
1:2:11

julia&gt; typeof(r)
StepRange{Int8,Int8}
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Core.Tuple" id="Core.Tuple"><code>Core.Tuple</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Tuple{Types...}(obj::GapObj; recursive = true)</code></pre><p>Return the tuple converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap21.html#X7B256AE5780F140A">GAP list</a><code>obj</code>. The entries of the list are converted to the requires types <code>Types...</code>, using <a href="#GAP.gap_to_julia"><code>gap_to_julia</code></a>. If <code>recursive</code> is <code>true</code> then the entries of the list are converted recursively, otherwise non-recursively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr("[ 1, 5 ]")
GAP: [ 1, 5 ]

julia&gt; Tuple{Int64,Int64}(val)
(1, 5)

julia&gt; val = GAP.evalstr("[ [ 1 ], [ 2 ] ]")
GAP: [ [ 1 ], [ 2 ] ]

julia&gt; Tuple{Any,Any}(val)
(Any[1], Any[2])

julia&gt; Tuple{GapObj,GapObj}(val, recursive = false)
(GAP: [ 1 ], GAP: [ 2 ])
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.BitArray" id="Base.BitArray"><code>Base.BitArray</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BitArray{1}(obj::GapObj)</code></pre><p>Return the 1-dimensional bit array converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap22.html#X7AC531DD79B6938E">GAP list of booleans</a><code>obj</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr("[ true, false, true ]")
GAP: [ true, false, true ]

julia&gt; BitArray{1}(val)
3-element BitArray{1}:
 1
 0
 1
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.Vector" id="Base.Vector"><code>Base.Vector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Vector{T}(obj::GapObj; recursive = true)</code></pre><p>Return the 1-dimensional array converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap21.html#X7B256AE5780F140A">GAP list</a><code>obj</code>. The entries of the list are converted to the type <code>T</code>, using <a href="#GAP.gap_to_julia"><code>gap_to_julia</code></a>. If <code>recursive</code> is <code>true</code> then the entries of the list are converted recursively, otherwise non-recursively.</p><p>If <code>T</code> is <code>UInt8</code> then <code>obj</code> may be a <a href="https://www.gap-system.org/Manuals/doc/ref/chap27.html#X7D28329B7EDB8F47">GAP string</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr("[ [ 1 ], [ 2 ] ]")
GAP: [ [ 1 ], [ 2 ] ]

julia&gt; Vector{Any}(val)
2-element Array{Any,1}:
 Any[1]
 Any[2]

julia&gt; Vector{Any}(val, recursive = false)
2-element Array{Any,1}:
 GAP: [ 1 ]
 GAP: [ 2 ]

julia&gt; val = GAP.evalstr( "NewVector( IsPlistVectorRep, Integers, [ 0, 2, 5 ] )" )
GAP: &lt;plist vector over Integers of length 3&gt;

julia&gt; Vector{Int64}( val )
3-element Array{Int64,1}:
 0
 2
 5

julia&gt; val = GAP.evalstr("\"abc\"")
GAP: "abc"

julia&gt; Vector{UInt8}(val)
3-element Array{UInt8,1}:
 0x61
 0x62
 0x63
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.Matrix" id="Base.Matrix"><code>Base.Matrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Matrix{T}(obj::GapObj; recursive = true)</code></pre><p>Return the 2-dimensional array converted from the GAP matrix <code>obj</code>, which can be a <a href="https://www.gap-system.org/Manuals/doc/ref/chap24.html#X812CCAB278643A59">GAP list of lists</a> or a <a href="https://www.gap-system.org/Manuals/doc/ref/chap26.html#X856C23B87E50F118">GAP matrix object</a>. The entries of the matrix are converted to the type <code>T</code>, using <a href="#GAP.gap_to_julia"><code>gap_to_julia</code></a>. If <code>recursive</code> is <code>true</code> then the entries are converted recursively, otherwise non-recursively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr("[ [ 1, 2 ], [ 3, 4 ] ]")
GAP: [ [ 1, 2 ], [ 3, 4 ] ]

julia&gt; Matrix{Int64}(val)
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; val = GAP.evalstr( "NewMatrix( IsPlistMatrixRep, Integers, 2, [ 0, 1, 2, 3 ] )" )
GAP: &lt;2x2-matrix over Integers&gt;

julia&gt; Matrix{Int64}(val)
2×2 Array{Int64,2}:
 0  1
 2  3
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.Dict" id="Base.Dict"><code>Base.Dict</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Dict{Symbol,T}(obj::GapObj; recursive = true)</code></pre><p>Return the dictionary converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap29.html#X7AA1073C7E943DD7">GAP record</a><code>obj</code>. If <code>recursive</code> is <code>true</code> then the values of the record components are recursively converted to objects of the type <code>T</code>, using <a href="#GAP.gap_to_julia"><code>gap_to_julia</code></a>, otherwise they are kept as they are.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr("rec( a:= 1, b:= 2 )")
GAP: rec( a := 1, b := 2 )

julia&gt; Dict{Symbol,Int}(val)
Dict{Symbol,Int64} with 2 entries:
  :a =&gt; 1
  :b =&gt; 2

julia&gt; val = GAP.evalstr("rec( l:= [ 1, 2 ] )")
GAP: rec( l := [ 1, 2 ] )

julia&gt; Dict{Symbol,Any}(val, recursive = false)
Dict{Symbol,Any} with 1 entry:
  :l =&gt; GAP: [ 1, 2 ]

julia&gt; Dict{Symbol,Any}(val, recursive = true)
Dict{Symbol,Any} with 1 entry:
  :l =&gt; Any[1, 2]

julia&gt; Dict{Symbol,Array{Int,1}}(val, recursive = true)
Dict{Symbol,Array{Int64,1}} with 1 entry:
  :l =&gt; [1, 2]
</code></pre></div></div></section><h2><a class="nav-anchor" href="#Convenience-adapters-1" id="Convenience-adapters-1">Convenience adapters</a></h2><p>This section describes how one can manipulate GAP objects from the Julia side, using Julia syntax features.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#GAP.Globals" id="GAP.Globals"><code>GAP.Globals</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">Globals</code></pre><p>This is a global object that gives access to all global variables of the current GAP session via <code>getproperty</code> and <code>setproperty!</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; GAP.Globals.Size    # a global GAP function
GAP: &lt;Attribute "Size"&gt;

julia&gt; GAP.Globals.size    # there is no GAP variable with this name
ERROR: GAP variable size not bound
[...]

julia&gt; hasproperty( GAP.Globals, :size )
false

julia&gt; GAP.Globals.size = 17;

julia&gt; hasproperty( GAP.Globals, :size )
true

julia&gt; GAP.Globals.size
17

julia&gt; GAP.Globals.Julia   # Julia objects can be values of GAP variables
Main
</code></pre></div></div></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>call_gap_func</code>. Check Documenter's build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#GAP.evalstr" id="GAP.evalstr"><code>GAP.evalstr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">evalstr(cmd::String)</code></pre><p>Let GAP execute the command(s) given by <code>cmd</code>; if the last command has a result then return it, otherwise return <code>nothing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; GAP.evalstr( "1+2" )
3

julia&gt; GAP.evalstr( "x:= []" )
GAP: [  ]

julia&gt; GAP.evalstr( "y:= 2; Add( x, 1 )" )

julia&gt; GAP.evalstr( "x" )
GAP: [ 1 ]
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.getindex" id="Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getindex(x::GapObj, i::Int64)
getindex(x::GapObj, i::Int64, j::Int64)
getindex(x::GapObj, l::Union{Vector{T},AbstractRange{T}}) where {T&lt;:Integer}</code></pre><p>Return the entry at position <code>i</code> or at position <code>(i,j)</code> in <code>x</code>, or the list of entries in <code>x</code> at the positions described by <code>l</code>, provided that <code>x</code> is a GAP list.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; l = GAP.evalstr( "[ 1, 2, 3, 5, 8, 13 ]" )
GAP: [ 1, 2, 3, 5, 8, 13 ]

julia&gt; l[4]
5

julia&gt; l[end]
13

julia&gt; l[2:4]
GAP: [ 2, 3, 5 ]

julia&gt; l[[1,4,4]]
GAP: [ 1, 5, 5 ]

julia&gt; m = GAP.evalstr( "[ [ 1, 2 ], [ 3, 4 ] ]" )
GAP: [ [ 1, 2 ], [ 3, 4 ] ]

julia&gt; m[1,1]
1

julia&gt; m[1,2]
2

julia&gt; m[2,1]
3
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.setindex!" id="Base.setindex!"><code>Base.setindex!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setindex!(x::GapObj, v::Any, i::Int64)
setindex!(x::GapObj, v::Any, i::Int64, j::Int64)
setindex!(x::GapObj, v::Any, l::Union{Vector{T},AbstractRange{T}}) where {T&lt;:Integer}</code></pre><p>Set the entry at position <code>i</code> or <code>(i,j)</code> in <code>x</code> to <code>v</code>, or set the entries at the positions in <code>x</code> that are described by <code>l</code> to the entries in <code>v</code>, provided that <code>x</code> is a GAP list.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; l = GAP.evalstr( "[ 1, 2, 3, 5, 8, 13 ]" )
GAP: [ 1, 2, 3, 5, 8, 13 ]

julia&gt; l[1] = 0
0

julia&gt; l[8] = -1
-1

julia&gt; l[2:4] = [ 7, 7, 7 ]
3-element Array{Int64,1}:
 7
 7
 7

julia&gt; l
GAP: [ 0, 7, 7, 7, 8, 13,, -1 ]

julia&gt; m = GAP.evalstr( "[ [ 1, 2 ], [ 3, 4 ] ]" )
GAP: [ [ 1, 2 ], [ 3, 4 ] ]

julia&gt; m[1,2] = 0
0

julia&gt; m
GAP: [ [ 1, 0 ], [ 3, 4 ] ]
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.getproperty" id="Base.getproperty"><code>Base.getproperty</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">getproperty(x::GapObj, f::Symbol)
getproperty(x::GapObj, f::Union{AbstractString,Int64})</code></pre><p>Return the record component of the GAP record <code>x</code> that is described by <code>f</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; r = GAP.evalstr( "rec( a:= 1 )" )
GAP: rec( a := 1 )

julia&gt; r.a
1
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.setproperty!" id="Base.setproperty!"><code>Base.setproperty!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setproperty!(x::GapObj, f::Symbol, v)
setproperty!(x::GapObj, f::Union{AbstractString,Int64}, v)</code></pre><p>Set the record component of the GAP record <code>x</code> that is described by <code>f</code> to the value <code>v</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; r = GAP.evalstr( "rec( a:= 1 )" )
GAP: rec( a := 1 )

julia&gt; r.b = 0
0

julia&gt; r
GAP: rec( a := 1, b := 0 )
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#Base.hasproperty" id="Base.hasproperty"><code>Base.hasproperty</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">hasproperty(x::GapObj, f::Symbol)
hasproperty(x::GapObj, f::Union{AbstractString,Int64})</code></pre><p>Return <code>true</code> if the GAP record <code>x</code> has a component that is described by <code>f</code>, and <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; r = GAP.evalstr( "rec( a:= 1 )" )
GAP: rec( a := 1 )

julia&gt; hasproperty( r, :a )
true

julia&gt; hasproperty( r, :b )
false

julia&gt; r.b = 2
2

julia&gt; hasproperty( r, :b )
true

julia&gt; r
GAP: rec( a := 1, b := 2 )
</code></pre></div></div></section><p>For the following Julia functions, methods are provided that deal with the case that the arguments are GAP objects; they delegate to the corresponding GAP operations.</p><table><tbody><tr><th style="text-align: right">Julia</th><th style="text-align: right">GAP</th></tr><tr><td style="text-align: right"><code>length</code></td><td style="text-align: right"><code>Length</code></td></tr><tr><td style="text-align: right"><code>in</code></td><td style="text-align: right"><code>\in</code></td></tr><tr><td style="text-align: right"><code>zero</code></td><td style="text-align: right"><code>ZERO</code></td></tr><tr><td style="text-align: right"><code>one</code></td><td style="text-align: right"><code>ONE</code></td></tr><tr><td style="text-align: right"><code>-</code> (unary)</td><td style="text-align: right"><code>AINV</code></td></tr><tr><td style="text-align: right"><code>+</code></td><td style="text-align: right"><code>SUM</code></td></tr><tr><td style="text-align: right"><code>-</code> (binary)</td><td style="text-align: right"><code>DIFF</code></td></tr><tr><td style="text-align: right"><code>*</code></td><td style="text-align: right"><code>PROD</code></td></tr><tr><td style="text-align: right"><code>/</code></td><td style="text-align: right"><code>QUO</code></td></tr><tr><td style="text-align: right"><code>\</code></td><td style="text-align: right"><code>LQUO</code></td></tr><tr><td style="text-align: right"><code>^</code></td><td style="text-align: right"><code>POW</code></td></tr><tr><td style="text-align: right"><code>mod</code></td><td style="text-align: right"><code>MOD</code></td></tr><tr><td style="text-align: right"><code>&lt;</code></td><td style="text-align: right"><code>LT</code></td></tr><tr><td style="text-align: right"><code>==</code></td><td style="text-align: right"><code>EQ</code></td></tr></tbody></table><pre><code class="language-julia-repl">julia&gt; l = GAP.julia_to_gap( [ 1, 3, 7, 15 ] )
GAP: [ 1, 3, 7, 15 ]

julia&gt; m = GAP.julia_to_gap( [ 1 2; 3 4 ] )
GAP: [ [ 1, 2 ], [ 3, 4 ] ]

julia&gt; length( l )
4

julia&gt; length( m )  # different from Julia's behaviour
2

julia&gt; 1 in l
true

julia&gt; 2 in l
false

julia&gt; zero( l )
GAP: [ 0, 0, 0, 0 ]

julia&gt; one( m )
GAP: [ [ 1, 0 ], [ 0, 1 ] ]

julia&gt; - l
GAP: [ -1, -3, -7, -15 ]

julia&gt; l + 1
GAP: [ 2, 4, 8, 16 ]

julia&gt; l + l
GAP: [ 2, 6, 14, 30 ]

julia&gt; m + m
GAP: [ [ 2, 4 ], [ 6, 8 ] ]

julia&gt; 1 - m
GAP: [ [ 0, -1 ], [ -2, -3 ] ]

julia&gt; l * l
284

julia&gt; l * m
GAP: [ 10, 14 ]

julia&gt; m * m
GAP: [ [ 7, 10 ], [ 15, 22 ] ]

julia&gt; 1 / m
GAP: [ [ -2, 1 ], [ 3/2, -1/2 ] ]

julia&gt; m / 2
GAP: [ [ 1/2, 1 ], [ 3/2, 2 ] ]

julia&gt; 2 \ m
GAP: [ [ 1/2, 1 ], [ 3/2, 2 ] ]

julia&gt; m ^ 2
GAP: [ [ 7, 10 ], [ 15, 22 ] ]

julia&gt; m ^ -1
GAP: [ [ -2, 1 ], [ 3/2, -1/2 ] ]

julia&gt; mod( l, 3 )
GAP: [ 1, 0, 1, 0 ]

julia&gt; m &lt; 2 * m
true

julia&gt; m^2 - 5 * m == 2 * one( m )
true
</code></pre><h2><a class="nav-anchor" href="#Access-to-the-GAP-help-system-1" id="Access-to-the-GAP-help-system-1">Access to the GAP help system</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#GAP.show_gap_help" id="GAP.show_gap_help"><code>GAP.show_gap_help</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">show_gap_help(topic::String, onlyexact::Bool = false)</code></pre><p>Print the information from the GAP help system about <code>topic</code> to the screen. If <code>onlyexact</code> is <code>true</code> then only exact matches are shown, otherwise all matches. For example, <code>GAP.show_gap_help("Size")</code> shows also documentation for <code>SizeScreen</code> and <code>SizesPerfectGroups</code>, whereas <code>GAP.show_gap_help("Size", true)</code> shows only documentation for <code>Size</code>.</p><p>For the variant showing all matches, one can also enter <code>?GAP.Globals.Size</code> at the Julia prompt instead of calling <code>show_gap_help</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; GAP.show_gap_help( "Size" )
[...]  # more than 50 entries from GAP manuals

hepl?&gt; GAP.Globals.Size
[...]  # the same

julia&gt; GAP.show_gap_help( "Size", true )
[...]  # about 15 entries from GAP manuals
</code></pre></div></div></section><h2><a class="nav-anchor" href="#Managing-GAP-packages-1" id="Managing-GAP-packages-1">Managing GAP packages</a></h2><p>The following functions allow one to load/install/update/remove GAP packages.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#GAP.Packages.load" id="GAP.Packages.load"><code>GAP.Packages.load</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">load(spec::String, version::String = ""; install = false)</code></pre><p>Try to load the newest installed version of the GAP package with name <code>spec</code>. Return <code>true</code> if this is successful, and <code>false</code> otherwise.</p><p>The function calls <a href="https://www.gap-system.org/Manuals/doc/ref/chap76.html#X79B373A77B29D1F5">GAP's <code>LoadPackage</code> function</a>; the package banner is not printed.</p><p>If <code>install</code> is set to <code>true</code> and the required GAP package is not yet installed then <a href="#GAP.Packages.install"><code>install</code></a> is called first, in order to install the newest released version of the package.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#GAP.Packages.install" id="GAP.Packages.install"><code>GAP.Packages.install</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">install(spec::String, interactive::Bool = true)</code></pre><p>Download and install the newest released version of the GAP package given by <code>spec</code> in the <code>pkg</code> subdirectory of GAP's build directory (variable <code>GAP.GAPROOT</code>). Return <code>true</code> if the installation is successful or if the package was already installed, and <code>false</code> otherwise.</p><p><code>spec</code> can be either the name of a package or the URL of an archive or repository containing a package, or the URL of a <code>PackageInfo.g</code> file.</p><p>The function uses <a href="https://www.gap-system.org/Manuals/pkg/PackageManager-1.0/doc/chap2.html#X81A6FF1B81D004BA">the function <code>InstallPackage</code> from GAP's package <code>PackageManager</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#GAP.Packages.update" id="GAP.Packages.update"><code>GAP.Packages.update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">update(spec::String)</code></pre><p>Update the GAP package given by <code>spec</code> that is installed in the <code>pkg</code> subdirectory of GAP's build directory (variable <code>GAP.GAPROOT</code>), to the latest version. Return <code>true</code> if a newer version was installed successfully, or if no newer version is available, and <code>false</code> otherwise.</p><p><code>spec</code> can be either the name of a package or the URL of an archive or repository containing a package, or the URL of a <code>PackageInfo.g</code> file.</p><p>The function uses <a href="https://www.gap-system.org/Manuals/pkg/PackageManager-1.0/doc/chap2.html#X7A3A079387DAA79A">the function <code>UpdatePackage</code> from GAP's package <code>PackageManager</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#GAP.Packages.remove" id="GAP.Packages.remove"><code>GAP.Packages.remove</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">remove(spec::String)</code></pre><p>Remove the GAP package with name <code>spec</code> that is installed in the <code>pkg</code> subdirectory of GAP's build directory (variable <code>GAP.GAPROOT</code>). Return <code>true</code> if the removal was successful, and <code>false</code> otherwise.</p><p>The function uses <a href="https://www.gap-system.org/Manuals/pkg/PackageManager-1.0/doc/chap2.html#X8011AC33841B515C">the function <code>RemovePackage</code> from GAP's package <code>PackageManager</code></a>.</p></div></div></section><h2><a class="nav-anchor" href="#Other-1" id="Other-1">Other</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" href="#GAP.prompt" id="GAP.prompt"><code>GAP.prompt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">prompt()</code></pre><p>Start a GAP prompt where you can enter GAP commands as in a regular GAP session. This prompt can be left as any GAP prompt by either entering <code>quit;</code> or pressing ctrl-D, which returns to the Julia prompt.</p><p>This GAP prompt allows to quickly switch between writing Julia and GAP code in a session where all data is shared.</p></div></div></section><h2><a class="nav-anchor" href="#Index-1" id="Index-1">Index</a></h2><ul><li><a href="#GAP.Globals"><code>GAP.Globals</code></a></li><li><a href="#Base.BitArray"><code>Base.BitArray</code></a></li><li><a href="#Base.Cuchar"><code>Base.Cuchar</code></a></li><li><a href="#Base.Dict"><code>Base.Dict</code></a></li><li><a href="#Base.GMP.BigInt"><code>Base.GMP.BigInt</code></a></li><li><a href="#Base.Matrix"><code>Base.Matrix</code></a></li><li><a href="#Base.Rational"><code>Base.Rational</code></a></li><li><a href="#Base.StepRange"><code>Base.StepRange</code></a></li><li><a href="#Base.UnitRange"><code>Base.UnitRange</code></a></li><li><a href="#Base.Vector"><code>Base.Vector</code></a></li><li><a href="#Core.Char"><code>Core.Char</code></a></li><li><a href="#Core.Float64"><code>Core.Float64</code></a></li><li><a href="#Core.Int128"><code>Core.Int128</code></a></li><li><a href="#Core.String"><code>Core.String</code></a></li><li><a href="#Core.Symbol"><code>Core.Symbol</code></a></li><li><a href="#Core.Tuple"><code>Core.Tuple</code></a></li><li><a href="#GAP.FFE"><code>GAP.FFE</code></a></li><li><a href="#GAP.GapObj"><code>GAP.GapObj</code></a></li><li><a href="#Base.big"><code>Base.big</code></a></li><li><a href="#Base.convert"><code>Base.convert</code></a></li><li><a href="#Base.getindex"><code>Base.getindex</code></a></li><li><a href="#Base.getproperty"><code>Base.getproperty</code></a></li><li><a href="#Base.hasproperty"><code>Base.hasproperty</code></a></li><li><a href="#Base.setindex!"><code>Base.setindex!</code></a></li><li><a href="#Base.setproperty!"><code>Base.setproperty!</code></a></li><li><a href="#GAP.Packages.install"><code>GAP.Packages.install</code></a></li><li><a href="#GAP.Packages.load"><code>GAP.Packages.load</code></a></li><li><a href="#GAP.Packages.remove"><code>GAP.Packages.remove</code></a></li><li><a href="#GAP.Packages.update"><code>GAP.Packages.update</code></a></li><li><a href="#GAP.evalstr"><code>GAP.evalstr</code></a></li><li><a href="#GAP.gap_to_julia"><code>GAP.gap_to_julia</code></a></li><li><a href="#GAP.julia_to_gap"><code>GAP.julia_to_gap</code></a></li><li><a href="#GAP.prompt"><code>GAP.prompt</code></a></li><li><a href="#GAP.show_gap_help"><code>GAP.show_gap_help</code></a></li><li><a href="#GAP.@g_str"><code>GAP.@g_str</code></a></li><li><a href="#GAP.@gap"><code>GAP.@gap</code></a></li></ul><footer><hr/></footer></article></body></HTML>